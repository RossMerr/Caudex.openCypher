// Generated from Cypher.g4 by ANTLR 4.7.

package openCypher // Cypher
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 130, 1603,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 3, 2, 5, 2, 208, 10, 2, 3, 2, 3, 2, 5, 2, 212,
	10, 2, 3, 2, 5, 2, 215, 10, 2, 3, 2, 5, 2, 218, 10, 2, 3, 2, 3, 2, 3, 3,
	3, 3, 3, 4, 3, 4, 5, 4, 226, 10, 4, 3, 5, 3, 5, 5, 5, 230, 10, 5, 3, 5,
	7, 5, 233, 10, 5, 12, 5, 14, 5, 236, 11, 5, 3, 6, 3, 6, 3, 6, 3, 6, 5,
	6, 242, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 247, 10, 6, 3, 6, 5, 6, 250, 10,
	6, 3, 7, 3, 7, 5, 7, 254, 10, 7, 3, 8, 3, 8, 3, 8, 5, 8, 259, 10, 8, 3,
	9, 3, 9, 3, 9, 3, 10, 3, 10, 5, 10, 266, 10, 10, 3, 10, 7, 10, 269, 10,
	10, 12, 10, 14, 10, 272, 11, 10, 3, 10, 5, 10, 275, 10, 10, 3, 10, 6, 10,
	278, 10, 10, 13, 10, 14, 10, 279, 3, 10, 5, 10, 283, 10, 10, 3, 10, 5,
	10, 286, 10, 10, 3, 11, 3, 11, 5, 11, 290, 10, 11, 3, 11, 7, 11, 293, 10,
	11, 12, 11, 14, 11, 296, 11, 11, 3, 11, 5, 11, 299, 10, 11, 3, 11, 5, 11,
	302, 10, 11, 3, 12, 3, 12, 3, 12, 5, 12, 307, 10, 12, 3, 12, 3, 12, 5,
	12, 311, 10, 12, 3, 12, 3, 12, 5, 12, 315, 10, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 5, 12, 321, 10, 12, 7, 12, 323, 10, 12, 12, 12, 14, 12, 326, 11,
	12, 3, 12, 3, 12, 3, 13, 3, 13, 5, 13, 332, 10, 13, 7, 13, 334, 10, 13,
	12, 13, 14, 13, 337, 11, 13, 3, 14, 3, 14, 5, 14, 341, 10, 14, 7, 14, 343,
	10, 14, 12, 14, 14, 14, 346, 11, 14, 3, 15, 3, 15, 5, 15, 350, 10, 15,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 357, 10, 16, 3, 17, 3, 17, 3,
	17, 5, 17, 362, 10, 17, 3, 18, 3, 18, 5, 18, 366, 10, 18, 3, 18, 3, 18,
	5, 18, 370, 10, 18, 3, 18, 3, 18, 5, 18, 374, 10, 18, 3, 18, 5, 18, 377,
	10, 18, 3, 19, 3, 19, 5, 19, 381, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 20, 3, 20, 5, 20, 391, 10, 20, 3, 20, 3, 20, 3, 20, 7, 20,
	396, 10, 20, 12, 20, 14, 20, 399, 11, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 411, 10, 21, 3, 22, 3, 22,
	5, 22, 415, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 5, 23, 421, 10, 23, 3,
	23, 3, 23, 3, 23, 7, 23, 426, 10, 23, 12, 23, 14, 23, 429, 11, 23, 3, 24,
	3, 24, 5, 24, 433, 10, 24, 3, 24, 3, 24, 5, 24, 437, 10, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 5, 24, 443, 10, 24, 3, 24, 3, 24, 5, 24, 447, 10, 24,
	3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 453, 10, 24, 3, 24, 3, 24, 5, 24, 457,
	10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 463, 10, 24, 3, 24, 3, 24, 5,
	24, 467, 10, 24, 3, 25, 3, 25, 5, 25, 471, 10, 25, 3, 25, 3, 25, 5, 25,
	475, 10, 25, 3, 25, 3, 25, 5, 25, 479, 10, 25, 3, 25, 3, 25, 5, 25, 483,
	10, 25, 3, 25, 7, 25, 486, 10, 25, 12, 25, 14, 25, 489, 11, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 5, 26, 495, 10, 26, 3, 26, 3, 26, 5, 26, 499, 10,
	26, 3, 26, 7, 26, 502, 10, 26, 12, 26, 14, 26, 505, 11, 26, 3, 27, 3, 27,
	3, 27, 3, 27, 5, 27, 511, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 517,
	10, 28, 3, 28, 3, 28, 3, 28, 5, 28, 522, 10, 28, 3, 29, 3, 29, 3, 29, 3,
	29, 5, 29, 528, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 534, 10, 29,
	3, 30, 3, 30, 5, 30, 538, 10, 30, 3, 30, 3, 30, 5, 30, 542, 10, 30, 3,
	30, 7, 30, 545, 10, 30, 12, 30, 14, 30, 548, 11, 30, 3, 30, 5, 30, 551,
	10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 558, 10, 31, 3, 31, 3,
	31, 3, 32, 3, 32, 5, 32, 564, 10, 32, 3, 32, 5, 32, 567, 10, 32, 3, 32,
	3, 32, 3, 32, 5, 32, 572, 10, 32, 3, 32, 5, 32, 575, 10, 32, 3, 33, 3,
	33, 5, 33, 579, 10, 33, 3, 33, 5, 33, 582, 10, 33, 3, 33, 3, 33, 3, 33,
	3, 34, 3, 34, 3, 34, 5, 34, 590, 10, 34, 3, 34, 3, 34, 5, 34, 594, 10,
	34, 3, 34, 3, 34, 5, 34, 598, 10, 34, 3, 35, 3, 35, 5, 35, 602, 10, 35,
	3, 35, 3, 35, 5, 35, 606, 10, 35, 3, 35, 7, 35, 609, 10, 35, 12, 35, 14,
	35, 612, 11, 35, 3, 35, 3, 35, 5, 35, 616, 10, 35, 3, 35, 3, 35, 5, 35,
	620, 10, 35, 3, 35, 7, 35, 623, 10, 35, 12, 35, 14, 35, 626, 11, 35, 5,
	35, 628, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36,
	637, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 646,
	10, 37, 3, 37, 7, 37, 649, 10, 37, 12, 37, 14, 37, 652, 11, 37, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 5, 40, 664,
	10, 40, 3, 40, 5, 40, 667, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3,
	42, 5, 42, 675, 10, 42, 3, 42, 3, 42, 5, 42, 679, 10, 42, 3, 42, 7, 42,
	682, 10, 42, 12, 42, 14, 42, 685, 11, 42, 3, 43, 3, 43, 5, 43, 689, 10,
	43, 3, 43, 3, 43, 5, 43, 693, 10, 43, 3, 43, 3, 43, 3, 43, 5, 43, 698,
	10, 43, 3, 44, 3, 44, 3, 45, 3, 45, 5, 45, 704, 10, 45, 3, 45, 7, 45, 707,
	10, 45, 12, 45, 14, 45, 710, 11, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45,
	716, 10, 45, 3, 46, 3, 46, 5, 46, 720, 10, 46, 3, 46, 3, 46, 5, 46, 724,
	10, 46, 5, 46, 726, 10, 46, 3, 46, 3, 46, 5, 46, 730, 10, 46, 5, 46, 732,
	10, 46, 3, 46, 3, 46, 5, 46, 736, 10, 46, 5, 46, 738, 10, 46, 3, 46, 3,
	46, 3, 47, 3, 47, 5, 47, 744, 10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 5, 48,
	750, 10, 48, 3, 48, 3, 48, 5, 48, 754, 10, 48, 3, 48, 5, 48, 757, 10, 48,
	3, 48, 5, 48, 760, 10, 48, 3, 48, 3, 48, 5, 48, 764, 10, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 5, 48, 770, 10, 48, 3, 48, 3, 48, 5, 48, 774, 10, 48,
	3, 48, 5, 48, 777, 10, 48, 3, 48, 5, 48, 780, 10, 48, 3, 48, 3, 48, 3,
	48, 3, 48, 5, 48, 786, 10, 48, 3, 48, 5, 48, 789, 10, 48, 3, 48, 5, 48,
	792, 10, 48, 3, 48, 3, 48, 5, 48, 796, 10, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 5, 48, 802, 10, 48, 3, 48, 5, 48, 805, 10, 48, 3, 48, 5, 48, 808, 10,
	48, 3, 48, 3, 48, 5, 48, 812, 10, 48, 3, 49, 3, 49, 5, 49, 816, 10, 49,
	3, 49, 3, 49, 5, 49, 820, 10, 49, 5, 49, 822, 10, 49, 3, 49, 3, 49, 5,
	49, 826, 10, 49, 5, 49, 828, 10, 49, 3, 49, 5, 49, 831, 10, 49, 3, 49,
	3, 49, 5, 49, 835, 10, 49, 5, 49, 837, 10, 49, 3, 49, 3, 49, 3, 50, 3,
	50, 5, 50, 843, 10, 50, 3, 51, 3, 51, 5, 51, 847, 10, 51, 3, 51, 3, 51,
	5, 51, 851, 10, 51, 3, 51, 3, 51, 5, 51, 855, 10, 51, 3, 51, 5, 51, 858,
	10, 51, 3, 51, 7, 51, 861, 10, 51, 12, 51, 14, 51, 864, 11, 51, 3, 52,
	3, 52, 5, 52, 868, 10, 52, 3, 52, 7, 52, 871, 10, 52, 12, 52, 14, 52, 874,
	11, 52, 3, 53, 3, 53, 5, 53, 878, 10, 53, 3, 53, 3, 53, 3, 54, 3, 54, 5,
	54, 884, 10, 54, 3, 54, 3, 54, 5, 54, 888, 10, 54, 5, 54, 890, 10, 54,
	3, 54, 3, 54, 5, 54, 894, 10, 54, 3, 54, 3, 54, 5, 54, 898, 10, 54, 5,
	54, 900, 10, 54, 5, 54, 902, 10, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 57,
	3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 7, 58, 915, 10, 58, 12, 58, 14,
	58, 918, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 925, 10, 59,
	12, 59, 14, 59, 928, 11, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60,
	935, 10, 60, 12, 60, 14, 60, 938, 11, 60, 3, 61, 3, 61, 5, 61, 942, 10,
	61, 7, 61, 944, 10, 61, 12, 61, 14, 61, 947, 11, 61, 3, 61, 3, 61, 3, 62,
	3, 62, 5, 62, 953, 10, 62, 3, 62, 7, 62, 956, 10, 62, 12, 62, 14, 62, 959,
	11, 62, 3, 63, 3, 63, 5, 63, 963, 10, 63, 3, 63, 3, 63, 5, 63, 967, 10,
	63, 3, 63, 3, 63, 5, 63, 971, 10, 63, 3, 63, 3, 63, 5, 63, 975, 10, 63,
	3, 63, 7, 63, 978, 10, 63, 12, 63, 14, 63, 981, 11, 63, 3, 64, 3, 64, 5,
	64, 985, 10, 64, 3, 64, 3, 64, 5, 64, 989, 10, 64, 3, 64, 3, 64, 5, 64,
	993, 10, 64, 3, 64, 3, 64, 5, 64, 997, 10, 64, 3, 64, 3, 64, 5, 64, 1001,
	10, 64, 3, 64, 3, 64, 5, 64, 1005, 10, 64, 3, 64, 7, 64, 1008, 10, 64,
	12, 64, 14, 64, 1011, 11, 64, 3, 65, 3, 65, 5, 65, 1015, 10, 65, 3, 65,
	3, 65, 5, 65, 1019, 10, 65, 3, 65, 7, 65, 1022, 10, 65, 12, 65, 14, 65,
	1025, 11, 65, 3, 66, 3, 66, 5, 66, 1029, 10, 66, 7, 66, 1031, 10, 66, 12,
	66, 14, 66, 1034, 11, 66, 3, 66, 3, 66, 3, 67, 3, 67, 5, 67, 1040, 10,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1047, 10, 67, 3, 67, 3, 67,
	5, 67, 1051, 10, 67, 3, 67, 3, 67, 5, 67, 1055, 10, 67, 3, 67, 3, 67, 5,
	67, 1059, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1074, 10, 67, 3, 67, 5, 67, 1077,
	10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 7, 67, 1090, 10, 67, 12, 67, 14, 67, 1093, 11, 67, 3, 68,
	3, 68, 5, 68, 1097, 10, 68, 3, 68, 3, 68, 5, 68, 1101, 10, 68, 7, 68, 1103,
	10, 68, 12, 68, 14, 68, 1106, 11, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	5, 69, 1113, 10, 69, 3, 69, 3, 69, 5, 69, 1117, 10, 69, 3, 69, 3, 69, 5,
	69, 1121, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1128, 10, 69,
	3, 69, 3, 69, 5, 69, 1132, 10, 69, 3, 69, 3, 69, 5, 69, 1136, 10, 69, 3,
	69, 3, 69, 3, 69, 3, 69, 5, 69, 1142, 10, 69, 3, 69, 3, 69, 5, 69, 1146,
	10, 69, 3, 69, 3, 69, 5, 69, 1150, 10, 69, 3, 69, 5, 69, 1153, 10, 69,
	3, 69, 3, 69, 5, 69, 1157, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1163,
	10, 69, 3, 69, 3, 69, 5, 69, 1167, 10, 69, 3, 69, 3, 69, 5, 69, 1171, 10,
	69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1177, 10, 69, 3, 69, 3, 69, 5, 69,
	1181, 10, 69, 3, 69, 3, 69, 5, 69, 1185, 10, 69, 3, 69, 3, 69, 3, 69, 3,
	69, 5, 69, 1191, 10, 69, 3, 69, 3, 69, 5, 69, 1195, 10, 69, 3, 69, 3, 69,
	5, 69, 1199, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1205, 10, 69, 3,
	69, 3, 69, 5, 69, 1209, 10, 69, 3, 69, 3, 69, 5, 69, 1213, 10, 69, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1221, 10, 69, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 5, 70, 1229, 10, 70, 3, 71, 3, 71, 3, 72, 3, 72,
	5, 72, 1235, 10, 72, 3, 72, 3, 72, 5, 72, 1239, 10, 72, 3, 72, 3, 72, 5,
	72, 1243, 10, 72, 3, 72, 3, 72, 5, 72, 1247, 10, 72, 7, 72, 1249, 10, 72,
	12, 72, 14, 72, 1252, 11, 72, 5, 72, 1254, 10, 72, 3, 72, 3, 72, 3, 73,
	3, 73, 5, 73, 1260, 10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1265, 10, 73, 3,
	73, 3, 73, 3, 73, 5, 73, 1270, 10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1275,
	10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1280, 10, 73, 3, 73, 3, 73, 3, 73,
	5, 73, 1285, 10, 73, 3, 73, 5, 73, 1288, 10, 73, 3, 74, 3, 74, 5, 74, 1292,
	10, 74, 3, 74, 3, 74, 5, 74, 1296, 10, 74, 3, 74, 3, 74, 3, 75, 3, 75,
	5, 75, 1302, 10, 75, 3, 75, 6, 75, 1305, 10, 75, 13, 75, 14, 75, 1306,
	3, 76, 3, 76, 5, 76, 1311, 10, 76, 3, 76, 5, 76, 1314, 10, 76, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 5, 78, 1324, 10, 78, 3, 78,
	3, 78, 5, 78, 1328, 10, 78, 3, 78, 3, 78, 5, 78, 1332, 10, 78, 5, 78, 1334,
	10, 78, 3, 78, 3, 78, 5, 78, 1338, 10, 78, 3, 78, 3, 78, 5, 78, 1342, 10,
	78, 3, 78, 3, 78, 5, 78, 1346, 10, 78, 7, 78, 1348, 10, 78, 12, 78, 14,
	78, 1351, 11, 78, 5, 78, 1353, 10, 78, 3, 78, 3, 78, 3, 79, 3, 79, 5, 79,
	1359, 10, 79, 3, 80, 3, 80, 5, 80, 1363, 10, 80, 3, 80, 3, 80, 5, 80, 1367,
	10, 80, 3, 80, 3, 80, 5, 80, 1371, 10, 80, 3, 80, 3, 80, 5, 80, 1375, 10,
	80, 3, 80, 3, 80, 5, 80, 1379, 10, 80, 7, 80, 1381, 10, 80, 12, 80, 14,
	80, 1384, 11, 80, 5, 80, 1386, 10, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82,
	3, 82, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 7, 84, 1400, 10, 84, 12,
	84, 14, 84, 1403, 11, 84, 3, 85, 3, 85, 5, 85, 1407, 10, 85, 3, 85, 3,
	85, 5, 85, 1411, 10, 85, 3, 85, 3, 85, 5, 85, 1415, 10, 85, 3, 85, 5, 85,
	1418, 10, 85, 3, 85, 5, 85, 1421, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86, 5,
	86, 1427, 10, 86, 3, 86, 3, 86, 5, 86, 1431, 10, 86, 3, 86, 3, 86, 5, 86,
	1435, 10, 86, 5, 86, 1437, 10, 86, 3, 86, 3, 86, 5, 86, 1441, 10, 86, 3,
	86, 3, 86, 5, 86, 1445, 10, 86, 3, 86, 3, 86, 5, 86, 1449, 10, 86, 5, 86,
	1451, 10, 86, 3, 86, 3, 86, 5, 86, 1455, 10, 86, 3, 86, 3, 86, 5, 86, 1459,
	10, 86, 3, 86, 3, 86, 3, 87, 3, 87, 5, 87, 1465, 10, 87, 3, 87, 3, 87,
	3, 88, 3, 88, 5, 88, 1471, 10, 88, 3, 88, 6, 88, 1474, 10, 88, 13, 88,
	14, 88, 1475, 3, 88, 3, 88, 5, 88, 1480, 10, 88, 3, 88, 3, 88, 5, 88, 1484,
	10, 88, 3, 88, 6, 88, 1487, 10, 88, 13, 88, 14, 88, 1488, 5, 88, 1491,
	10, 88, 3, 88, 5, 88, 1494, 10, 88, 3, 88, 3, 88, 5, 88, 1498, 10, 88,
	3, 88, 5, 88, 1501, 10, 88, 3, 88, 5, 88, 1504, 10, 88, 3, 88, 3, 88, 3,
	89, 3, 89, 5, 89, 1510, 10, 89, 3, 89, 3, 89, 5, 89, 1514, 10, 89, 3, 89,
	3, 89, 5, 89, 1518, 10, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 91, 3, 91, 5,
	91, 1526, 10, 91, 3, 92, 3, 92, 5, 92, 1530, 10, 92, 3, 92, 3, 92, 5, 92,
	1534, 10, 92, 3, 92, 3, 92, 5, 92, 1538, 10, 92, 3, 92, 3, 92, 5, 92, 1542,
	10, 92, 3, 92, 3, 92, 5, 92, 1546, 10, 92, 3, 92, 3, 92, 5, 92, 1550, 10,
	92, 3, 92, 3, 92, 5, 92, 1554, 10, 92, 3, 92, 3, 92, 5, 92, 1558, 10, 92,
	7, 92, 1560, 10, 92, 12, 92, 14, 92, 1563, 11, 92, 5, 92, 1565, 10, 92,
	3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 5, 93, 1572, 10, 93, 3, 94, 3, 94, 5,
	94, 1576, 10, 94, 3, 94, 6, 94, 1579, 10, 94, 13, 94, 14, 94, 1580, 3,
	95, 3, 95, 3, 96, 3, 96, 3, 97, 3, 97, 3, 98, 3, 98, 5, 98, 1591, 10, 98,
	3, 99, 3, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3,
	103, 3, 103, 2, 2, 104, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
	190, 192, 194, 196, 198, 200, 202, 204, 2, 12, 3, 2, 71, 74, 4, 2, 7, 7,
	16, 16, 3, 2, 92, 93, 3, 2, 102, 104, 3, 2, 112, 113, 6, 2, 49, 61, 64,
	85, 92, 99, 114, 123, 7, 2, 50, 50, 86, 91, 105, 105, 124, 124, 127, 127,
	4, 2, 22, 22, 30, 33, 4, 2, 23, 23, 34, 37, 4, 2, 7, 7, 38, 48, 2, 1832,
	2, 207, 3, 2, 2, 2, 4, 221, 3, 2, 2, 2, 6, 225, 3, 2, 2, 2, 8, 227, 3,
	2, 2, 2, 10, 249, 3, 2, 2, 2, 12, 253, 3, 2, 2, 2, 14, 258, 3, 2, 2, 2,
	16, 260, 3, 2, 2, 2, 18, 263, 3, 2, 2, 2, 20, 287, 3, 2, 2, 2, 22, 310,
	3, 2, 2, 2, 24, 335, 3, 2, 2, 2, 26, 344, 3, 2, 2, 2, 28, 349, 3, 2, 2,
	2, 30, 356, 3, 2, 2, 2, 32, 361, 3, 2, 2, 2, 34, 365, 3, 2, 2, 2, 36, 378,
	3, 2, 2, 2, 38, 388, 3, 2, 2, 2, 40, 410, 3, 2, 2, 2, 42, 412, 3, 2, 2,
	2, 44, 418, 3, 2, 2, 2, 46, 466, 3, 2, 2, 2, 48, 470, 3, 2, 2, 2, 50, 490,
	3, 2, 2, 2, 52, 510, 3, 2, 2, 2, 54, 512, 3, 2, 2, 2, 56, 523, 3, 2, 2,
	2, 58, 550, 3, 2, 2, 2, 60, 557, 3, 2, 2, 2, 62, 561, 3, 2, 2, 2, 64, 576,
	3, 2, 2, 2, 66, 586, 3, 2, 2, 2, 68, 627, 3, 2, 2, 2, 70, 636, 3, 2, 2,
	2, 72, 638, 3, 2, 2, 2, 74, 653, 3, 2, 2, 2, 76, 657, 3, 2, 2, 2, 78, 661,
	3, 2, 2, 2, 80, 668, 3, 2, 2, 2, 82, 672, 3, 2, 2, 2, 84, 697, 3, 2, 2,
	2, 86, 699, 3, 2, 2, 2, 88, 715, 3, 2, 2, 2, 90, 717, 3, 2, 2, 2, 92, 741,
	3, 2, 2, 2, 94, 811, 3, 2, 2, 2, 96, 813, 3, 2, 2, 2, 98, 842, 3, 2, 2,
	2, 100, 844, 3, 2, 2, 2, 102, 865, 3, 2, 2, 2, 104, 875, 3, 2, 2, 2, 106,
	881, 3, 2, 2, 2, 108, 903, 3, 2, 2, 2, 110, 905, 3, 2, 2, 2, 112, 907,
	3, 2, 2, 2, 114, 909, 3, 2, 2, 2, 116, 919, 3, 2, 2, 2, 118, 929, 3, 2,
	2, 2, 120, 945, 3, 2, 2, 2, 122, 950, 3, 2, 2, 2, 124, 960, 3, 2, 2, 2,
	126, 982, 3, 2, 2, 2, 128, 1012, 3, 2, 2, 2, 130, 1032, 3, 2, 2, 2, 132,
	1037, 3, 2, 2, 2, 134, 1094, 3, 2, 2, 2, 136, 1220, 3, 2, 2, 2, 138, 1228,
	3, 2, 2, 2, 140, 1230, 3, 2, 2, 2, 142, 1232, 3, 2, 2, 2, 144, 1287, 3,
	2, 2, 2, 146, 1289, 3, 2, 2, 2, 148, 1299, 3, 2, 2, 2, 150, 1308, 3, 2,
	2, 2, 152, 1315, 3, 2, 2, 2, 154, 1321, 3, 2, 2, 2, 156, 1358, 3, 2, 2,
	2, 158, 1360, 3, 2, 2, 2, 160, 1389, 3, 2, 2, 2, 162, 1391, 3, 2, 2, 2,
	164, 1393, 3, 2, 2, 2, 166, 1401, 3, 2, 2, 2, 168, 1404, 3, 2, 2, 2, 170,
	1424, 3, 2, 2, 2, 172, 1462, 3, 2, 2, 2, 174, 1490, 3, 2, 2, 2, 176, 1507,
	3, 2, 2, 2, 178, 1521, 3, 2, 2, 2, 180, 1525, 3, 2, 2, 2, 182, 1527, 3,
	2, 2, 2, 184, 1568, 3, 2, 2, 2, 186, 1573, 3, 2, 2, 2, 188, 1582, 3, 2,
	2, 2, 190, 1584, 3, 2, 2, 2, 192, 1586, 3, 2, 2, 2, 194, 1590, 3, 2, 2,
	2, 196, 1592, 3, 2, 2, 2, 198, 1594, 3, 2, 2, 2, 200, 1596, 3, 2, 2, 2,
	202, 1598, 3, 2, 2, 2, 204, 1600, 3, 2, 2, 2, 206, 208, 7, 128, 2, 2, 207,
	206, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 214,
	5, 4, 3, 2, 210, 212, 7, 128, 2, 2, 211, 210, 3, 2, 2, 2, 211, 212, 3,
	2, 2, 2, 212, 213, 3, 2, 2, 2, 213, 215, 7, 3, 2, 2, 214, 211, 3, 2, 2,
	2, 214, 215, 3, 2, 2, 2, 215, 217, 3, 2, 2, 2, 216, 218, 7, 128, 2, 2,
	217, 216, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2, 218, 219, 3, 2, 2, 2, 219,
	220, 7, 2, 2, 3, 220, 3, 3, 2, 2, 2, 221, 222, 5, 6, 4, 2, 222, 5, 3, 2,
	2, 2, 223, 226, 5, 8, 5, 2, 224, 226, 5, 56, 29, 2, 225, 223, 3, 2, 2,
	2, 225, 224, 3, 2, 2, 2, 226, 7, 3, 2, 2, 2, 227, 234, 5, 12, 7, 2, 228,
	230, 7, 128, 2, 2, 229, 228, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 231,
	3, 2, 2, 2, 231, 233, 5, 10, 6, 2, 232, 229, 3, 2, 2, 2, 233, 236, 3, 2,
	2, 2, 234, 232, 3, 2, 2, 2, 234, 235, 3, 2, 2, 2, 235, 9, 3, 2, 2, 2, 236,
	234, 3, 2, 2, 2, 237, 238, 7, 49, 2, 2, 238, 239, 7, 128, 2, 2, 239, 241,
	7, 50, 2, 2, 240, 242, 7, 128, 2, 2, 241, 240, 3, 2, 2, 2, 241, 242, 3,
	2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 250, 5, 12, 7, 2, 244, 246, 7, 49,
	2, 2, 245, 247, 7, 128, 2, 2, 246, 245, 3, 2, 2, 2, 246, 247, 3, 2, 2,
	2, 247, 248, 3, 2, 2, 2, 248, 250, 5, 12, 7, 2, 249, 237, 3, 2, 2, 2, 249,
	244, 3, 2, 2, 2, 250, 11, 3, 2, 2, 2, 251, 254, 5, 14, 8, 2, 252, 254,
	5, 22, 12, 2, 253, 251, 3, 2, 2, 2, 253, 252, 3, 2, 2, 2, 254, 13, 3, 2,
	2, 2, 255, 259, 5, 16, 9, 2, 256, 259, 5, 18, 10, 2, 257, 259, 5, 20, 11,
	2, 258, 255, 3, 2, 2, 2, 258, 256, 3, 2, 2, 2, 258, 257, 3, 2, 2, 2, 259,
	15, 3, 2, 2, 2, 260, 261, 5, 24, 13, 2, 261, 262, 5, 64, 33, 2, 262, 17,
	3, 2, 2, 2, 263, 270, 5, 32, 17, 2, 264, 266, 7, 128, 2, 2, 265, 264, 3,
	2, 2, 2, 265, 266, 3, 2, 2, 2, 266, 267, 3, 2, 2, 2, 267, 269, 5, 32, 17,
	2, 268, 265, 3, 2, 2, 2, 269, 272, 3, 2, 2, 2, 270, 268, 3, 2, 2, 2, 270,
	271, 3, 2, 2, 2, 271, 277, 3, 2, 2, 2, 272, 270, 3, 2, 2, 2, 273, 275,
	7, 128, 2, 2, 274, 273, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 276, 3,
	2, 2, 2, 276, 278, 5, 30, 16, 2, 277, 274, 3, 2, 2, 2, 278, 279, 3, 2,
	2, 2, 279, 277, 3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280, 285, 3, 2, 2, 2,
	281, 283, 7, 128, 2, 2, 282, 281, 3, 2, 2, 2, 282, 283, 3, 2, 2, 2, 283,
	284, 3, 2, 2, 2, 284, 286, 5, 64, 33, 2, 285, 282, 3, 2, 2, 2, 285, 286,
	3, 2, 2, 2, 286, 19, 3, 2, 2, 2, 287, 294, 5, 28, 15, 2, 288, 290, 7, 128,
	2, 2, 289, 288, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2,
	291, 293, 5, 30, 16, 2, 292, 289, 3, 2, 2, 2, 293, 296, 3, 2, 2, 2, 294,
	292, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 301, 3, 2, 2, 2, 296, 294,
	3, 2, 2, 2, 297, 299, 7, 128, 2, 2, 298, 297, 3, 2, 2, 2, 298, 299, 3,
	2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 302, 5, 64, 33, 2, 301, 298, 3, 2,
	2, 2, 301, 302, 3, 2, 2, 2, 302, 21, 3, 2, 2, 2, 303, 311, 5, 24, 13, 2,
	304, 306, 5, 28, 15, 2, 305, 307, 7, 128, 2, 2, 306, 305, 3, 2, 2, 2, 306,
	307, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308, 309, 5, 26, 14, 2, 309, 311,
	3, 2, 2, 2, 310, 303, 3, 2, 2, 2, 310, 304, 3, 2, 2, 2, 311, 312, 3, 2,
	2, 2, 312, 314, 5, 62, 32, 2, 313, 315, 7, 128, 2, 2, 314, 313, 3, 2, 2,
	2, 314, 315, 3, 2, 2, 2, 315, 324, 3, 2, 2, 2, 316, 317, 5, 24, 13, 2,
	317, 318, 5, 26, 14, 2, 318, 320, 5, 62, 32, 2, 319, 321, 7, 128, 2, 2,
	320, 319, 3, 2, 2, 2, 320, 321, 3, 2, 2, 2, 321, 323, 3, 2, 2, 2, 322,
	316, 3, 2, 2, 2, 323, 326, 3, 2, 2, 2, 324, 322, 3, 2, 2, 2, 324, 325,
	3, 2, 2, 2, 325, 327, 3, 2, 2, 2, 326, 324, 3, 2, 2, 2, 327, 328, 5, 14,
	8, 2, 328, 23, 3, 2, 2, 2, 329, 331, 5, 32, 17, 2, 330, 332, 7, 128, 2,
	2, 331, 330, 3, 2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 334, 3, 2, 2, 2, 333,
	329, 3, 2, 2, 2, 334, 337, 3, 2, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336,
	3, 2, 2, 2, 336, 25, 3, 2, 2, 2, 337, 335, 3, 2, 2, 2, 338, 340, 5, 30,
	16, 2, 339, 341, 7, 128, 2, 2, 340, 339, 3, 2, 2, 2, 340, 341, 3, 2, 2,
	2, 341, 343, 3, 2, 2, 2, 342, 338, 3, 2, 2, 2, 343, 346, 3, 2, 2, 2, 344,
	342, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 27, 3, 2, 2, 2, 346, 344, 3,
	2, 2, 2, 347, 350, 5, 42, 22, 2, 348, 350, 5, 38, 20, 2, 349, 347, 3, 2,
	2, 2, 349, 348, 3, 2, 2, 2, 350, 29, 3, 2, 2, 2, 351, 357, 5, 42, 22, 2,
	352, 357, 5, 38, 20, 2, 353, 357, 5, 48, 25, 2, 354, 357, 5, 44, 23, 2,
	355, 357, 5, 50, 26, 2, 356, 351, 3, 2, 2, 2, 356, 352, 3, 2, 2, 2, 356,
	353, 3, 2, 2, 2, 356, 354, 3, 2, 2, 2, 356, 355, 3, 2, 2, 2, 357, 31, 3,
	2, 2, 2, 358, 362, 5, 34, 18, 2, 359, 362, 5, 36, 19, 2, 360, 362, 5, 54,
	28, 2, 361, 358, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 361, 360, 3, 2, 2, 2,
	362, 33, 3, 2, 2, 2, 363, 364, 7, 51, 2, 2, 364, 366, 7, 128, 2, 2, 365,
	363, 3, 2, 2, 2, 365, 366, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 369,
	7, 52, 2, 2, 368, 370, 7, 128, 2, 2, 369, 368, 3, 2, 2, 2, 369, 370, 3,
	2, 2, 2, 370, 371, 3, 2, 2, 2, 371, 376, 5, 82, 42, 2, 372, 374, 7, 128,
	2, 2, 373, 372, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2,
	375, 377, 5, 80, 41, 2, 376, 373, 3, 2, 2, 2, 376, 377, 3, 2, 2, 2, 377,
	35, 3, 2, 2, 2, 378, 380, 7, 53, 2, 2, 379, 381, 7, 128, 2, 2, 380, 379,
	3, 2, 2, 2, 380, 381, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382, 383, 5, 112,
	57, 2, 383, 384, 7, 128, 2, 2, 384, 385, 7, 54, 2, 2, 385, 386, 7, 128,
	2, 2, 386, 387, 5, 178, 90, 2, 387, 37, 3, 2, 2, 2, 388, 390, 7, 55, 2,
	2, 389, 391, 7, 128, 2, 2, 390, 389, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2,
	391, 392, 3, 2, 2, 2, 392, 397, 5, 84, 43, 2, 393, 394, 7, 128, 2, 2, 394,
	396, 5, 40, 21, 2, 395, 393, 3, 2, 2, 2, 396, 399, 3, 2, 2, 2, 397, 395,
	3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 39, 3, 2, 2, 2, 399, 397, 3, 2,
	2, 2, 400, 401, 7, 56, 2, 2, 401, 402, 7, 128, 2, 2, 402, 403, 7, 52, 2,
	2, 403, 404, 7, 128, 2, 2, 404, 411, 5, 44, 23, 2, 405, 406, 7, 56, 2,
	2, 406, 407, 7, 128, 2, 2, 407, 408, 7, 57, 2, 2, 408, 409, 7, 128, 2,
	2, 409, 411, 5, 44, 23, 2, 410, 400, 3, 2, 2, 2, 410, 405, 3, 2, 2, 2,
	411, 41, 3, 2, 2, 2, 412, 414, 7, 57, 2, 2, 413, 415, 7, 128, 2, 2, 414,
	413, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 417,
	5, 82, 42, 2, 417, 43, 3, 2, 2, 2, 418, 420, 7, 58, 2, 2, 419, 421, 7,
	128, 2, 2, 420, 419, 3, 2, 2, 2, 420, 421, 3, 2, 2, 2, 421, 422, 3, 2,
	2, 2, 422, 427, 5, 46, 24, 2, 423, 424, 7, 4, 2, 2, 424, 426, 5, 46, 24,
	2, 425, 423, 3, 2, 2, 2, 426, 429, 3, 2, 2, 2, 427, 425, 3, 2, 2, 2, 427,
	428, 3, 2, 2, 2, 428, 45, 3, 2, 2, 2, 429, 427, 3, 2, 2, 2, 430, 432, 5,
	186, 94, 2, 431, 433, 7, 128, 2, 2, 432, 431, 3, 2, 2, 2, 432, 433, 3,
	2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 436, 7, 5, 2, 2, 435, 437, 7, 128,
	2, 2, 436, 435, 3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2,
	438, 439, 5, 112, 57, 2, 439, 467, 3, 2, 2, 2, 440, 442, 5, 178, 90, 2,
	441, 443, 7, 128, 2, 2, 442, 441, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443,
	444, 3, 2, 2, 2, 444, 446, 7, 5, 2, 2, 445, 447, 7, 128, 2, 2, 446, 445,
	3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 449, 5, 112,
	57, 2, 449, 467, 3, 2, 2, 2, 450, 452, 5, 178, 90, 2, 451, 453, 7, 128,
	2, 2, 452, 451, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2,
	454, 456, 7, 6, 2, 2, 455, 457, 7, 128, 2, 2, 456, 455, 3, 2, 2, 2, 456,
	457, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 459, 5, 112, 57, 2, 459, 467,
	3, 2, 2, 2, 460, 462, 5, 178, 90, 2, 461, 463, 7, 128, 2, 2, 462, 461,
	3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 465, 5, 102,
	52, 2, 465, 467, 3, 2, 2, 2, 466, 430, 3, 2, 2, 2, 466, 440, 3, 2, 2, 2,
	466, 450, 3, 2, 2, 2, 466, 460, 3, 2, 2, 2, 467, 47, 3, 2, 2, 2, 468, 469,
	7, 59, 2, 2, 469, 471, 7, 128, 2, 2, 470, 468, 3, 2, 2, 2, 470, 471, 3,
	2, 2, 2, 471, 472, 3, 2, 2, 2, 472, 474, 7, 60, 2, 2, 473, 475, 7, 128,
	2, 2, 474, 473, 3, 2, 2, 2, 474, 475, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2,
	476, 487, 5, 112, 57, 2, 477, 479, 7, 128, 2, 2, 478, 477, 3, 2, 2, 2,
	478, 479, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 482, 7, 4, 2, 2, 481,
	483, 7, 128, 2, 2, 482, 481, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483, 484,
	3, 2, 2, 2, 484, 486, 5, 112, 57, 2, 485, 478, 3, 2, 2, 2, 486, 489, 3,
	2, 2, 2, 487, 485, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 49, 3, 2, 2,
	2, 489, 487, 3, 2, 2, 2, 490, 491, 7, 61, 2, 2, 491, 492, 7, 128, 2, 2,
	492, 503, 5, 52, 27, 2, 493, 495, 7, 128, 2, 2, 494, 493, 3, 2, 2, 2, 494,
	495, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 498, 7, 4, 2, 2, 497, 499,
	7, 128, 2, 2, 498, 497, 3, 2, 2, 2, 498, 499, 3, 2, 2, 2, 499, 500, 3,
	2, 2, 2, 500, 502, 5, 52, 27, 2, 501, 494, 3, 2, 2, 2, 502, 505, 3, 2,
	2, 2, 503, 501, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 51, 3, 2, 2, 2,
	505, 503, 3, 2, 2, 2, 506, 507, 5, 178, 90, 2, 507, 508, 5, 102, 52, 2,
	508, 511, 3, 2, 2, 2, 509, 511, 5, 186, 94, 2, 510, 506, 3, 2, 2, 2, 510,
	509, 3, 2, 2, 2, 511, 53, 3, 2, 2, 2, 512, 513, 7, 62, 2, 2, 513, 514,
	7, 128, 2, 2, 514, 521, 5, 158, 80, 2, 515, 517, 7, 128, 2, 2, 516, 515,
	3, 2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 519, 7, 63,
	2, 2, 519, 520, 7, 128, 2, 2, 520, 522, 5, 58, 30, 2, 521, 516, 3, 2, 2,
	2, 521, 522, 3, 2, 2, 2, 522, 55, 3, 2, 2, 2, 523, 524, 7, 62, 2, 2, 524,
	527, 7, 128, 2, 2, 525, 528, 5, 158, 80, 2, 526, 528, 5, 160, 81, 2, 527,
	525, 3, 2, 2, 2, 527, 526, 3, 2, 2, 2, 528, 533, 3, 2, 2, 2, 529, 530,
	7, 128, 2, 2, 530, 531, 7, 63, 2, 2, 531, 532, 7, 128, 2, 2, 532, 534,
	5, 58, 30, 2, 533, 529, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 57, 3, 2,
	2, 2, 535, 546, 5, 60, 31, 2, 536, 538, 7, 128, 2, 2, 537, 536, 3, 2, 2,
	2, 537, 538, 3, 2, 2, 2, 538, 539, 3, 2, 2, 2, 539, 541, 7, 4, 2, 2, 540,
	542, 7, 128, 2, 2, 541, 540, 3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543,
	3, 2, 2, 2, 543, 545, 5, 60, 31, 2, 544, 537, 3, 2, 2, 2, 545, 548, 3,
	2, 2, 2, 546, 544, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 551, 3, 2, 2,
	2, 548, 546, 3, 2, 2, 2, 549, 551, 7, 7, 2, 2, 550, 535, 3, 2, 2, 2, 550,
	549, 3, 2, 2, 2, 551, 59, 3, 2, 2, 2, 552, 553, 5, 162, 82, 2, 553, 554,
	7, 128, 2, 2, 554, 555, 7, 54, 2, 2, 555, 556, 7, 128, 2, 2, 556, 558,
	3, 2, 2, 2, 557, 552, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 559, 3, 2,
	2, 2, 559, 560, 5, 178, 90, 2, 560, 61, 3, 2, 2, 2, 561, 566, 7, 64, 2,
	2, 562, 564, 7, 128, 2, 2, 563, 562, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2,
	564, 565, 3, 2, 2, 2, 565, 567, 7, 65, 2, 2, 566, 563, 3, 2, 2, 2, 566,
	567, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2, 568, 569, 7, 128, 2, 2, 569, 574,
	5, 66, 34, 2, 570, 572, 7, 128, 2, 2, 571, 570, 3, 2, 2, 2, 571, 572, 3,
	2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 575, 5, 80, 41, 2, 574, 571, 3, 2,
	2, 2, 574, 575, 3, 2, 2, 2, 575, 63, 3, 2, 2, 2, 576, 581, 7, 66, 2, 2,
	577, 579, 7, 128, 2, 2, 578, 577, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2, 579,
	580, 3, 2, 2, 2, 580, 582, 7, 65, 2, 2, 581, 578, 3, 2, 2, 2, 581, 582,
	3, 2, 2, 2, 582, 583, 3, 2, 2, 2, 583, 584, 7, 128, 2, 2, 584, 585, 5,
	66, 34, 2, 585, 65, 3, 2, 2, 2, 586, 589, 5, 68, 35, 2, 587, 588, 7, 128,
	2, 2, 588, 590, 5, 72, 37, 2, 589, 587, 3, 2, 2, 2, 589, 590, 3, 2, 2,
	2, 590, 593, 3, 2, 2, 2, 591, 592, 7, 128, 2, 2, 592, 594, 5, 74, 38, 2,
	593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 597, 3, 2, 2, 2, 595,
	596, 7, 128, 2, 2, 596, 598, 5, 76, 39, 2, 597, 595, 3, 2, 2, 2, 597, 598,
	3, 2, 2, 2, 598, 67, 3, 2, 2, 2, 599, 610, 7, 8, 2, 2, 600, 602, 7, 128,
	2, 2, 601, 600, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2,
	603, 605, 7, 4, 2, 2, 604, 606, 7, 128, 2, 2, 605, 604, 3, 2, 2, 2, 605,
	606, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 609, 5, 70, 36, 2, 608, 601,
	3, 2, 2, 2, 609, 612, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 610, 611, 3, 2,
	2, 2, 611, 628, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 613, 624, 5, 70, 36,
	2, 614, 616, 7, 128, 2, 2, 615, 614, 3, 2, 2, 2, 615, 616, 3, 2, 2, 2,
	616, 617, 3, 2, 2, 2, 617, 619, 7, 4, 2, 2, 618, 620, 7, 128, 2, 2, 619,
	618, 3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 623,
	5, 70, 36, 2, 622, 615, 3, 2, 2, 2, 623, 626, 3, 2, 2, 2, 624, 622, 3,
	2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 628, 3, 2, 2, 2, 626, 624, 3, 2, 2,
	2, 627, 599, 3, 2, 2, 2, 627, 613, 3, 2, 2, 2, 628, 69, 3, 2, 2, 2, 629,
	630, 5, 112, 57, 2, 630, 631, 7, 128, 2, 2, 631, 632, 7, 54, 2, 2, 632,
	633, 7, 128, 2, 2, 633, 634, 5, 178, 90, 2, 634, 637, 3, 2, 2, 2, 635,
	637, 5, 112, 57, 2, 636, 629, 3, 2, 2, 2, 636, 635, 3, 2, 2, 2, 637, 71,
	3, 2, 2, 2, 638, 639, 7, 67, 2, 2, 639, 640, 7, 128, 2, 2, 640, 641, 7,
	68, 2, 2, 641, 642, 7, 128, 2, 2, 642, 650, 5, 78, 40, 2, 643, 645, 7,
	4, 2, 2, 644, 646, 7, 128, 2, 2, 645, 644, 3, 2, 2, 2, 645, 646, 3, 2,
	2, 2, 646, 647, 3, 2, 2, 2, 647, 649, 5, 78, 40, 2, 648, 643, 3, 2, 2,
	2, 649, 652, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651,
	73, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 653, 654, 7, 69, 2, 2, 654, 655,
	7, 128, 2, 2, 655, 656, 5, 112, 57, 2, 656, 75, 3, 2, 2, 2, 657, 658, 7,
	70, 2, 2, 658, 659, 7, 128, 2, 2, 659, 660, 5, 112, 57, 2, 660, 77, 3,
	2, 2, 2, 661, 666, 5, 112, 57, 2, 662, 664, 7, 128, 2, 2, 663, 662, 3,
	2, 2, 2, 663, 664, 3, 2, 2, 2, 664, 665, 3, 2, 2, 2, 665, 667, 9, 2, 2,
	2, 666, 663, 3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 79, 3, 2, 2, 2, 668,
	669, 7, 75, 2, 2, 669, 670, 7, 128, 2, 2, 670, 671, 5, 112, 57, 2, 671,
	81, 3, 2, 2, 2, 672, 683, 5, 84, 43, 2, 673, 675, 7, 128, 2, 2, 674, 673,
	3, 2, 2, 2, 674, 675, 3, 2, 2, 2, 675, 676, 3, 2, 2, 2, 676, 678, 7, 4,
	2, 2, 677, 679, 7, 128, 2, 2, 678, 677, 3, 2, 2, 2, 678, 679, 3, 2, 2,
	2, 679, 680, 3, 2, 2, 2, 680, 682, 5, 84, 43, 2, 681, 674, 3, 2, 2, 2,
	682, 685, 3, 2, 2, 2, 683, 681, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684,
	83, 3, 2, 2, 2, 685, 683, 3, 2, 2, 2, 686, 688, 5, 178, 90, 2, 687, 689,
	7, 128, 2, 2, 688, 687, 3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 690, 3,
	2, 2, 2, 690, 692, 7, 5, 2, 2, 691, 693, 7, 128, 2, 2, 692, 691, 3, 2,
	2, 2, 692, 693, 3, 2, 2, 2, 693, 694, 3, 2, 2, 2, 694, 695, 5, 86, 44,
	2, 695, 698, 3, 2, 2, 2, 696, 698, 5, 86, 44, 2, 697, 686, 3, 2, 2, 2,
	697, 696, 3, 2, 2, 2, 698, 85, 3, 2, 2, 2, 699, 700, 5, 88, 45, 2, 700,
	87, 3, 2, 2, 2, 701, 708, 5, 90, 46, 2, 702, 704, 7, 128, 2, 2, 703, 702,
	3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 707, 5, 92,
	47, 2, 706, 703, 3, 2, 2, 2, 707, 710, 3, 2, 2, 2, 708, 706, 3, 2, 2, 2,
	708, 709, 3, 2, 2, 2, 709, 716, 3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 711,
	712, 7, 9, 2, 2, 712, 713, 5, 88, 45, 2, 713, 714, 7, 10, 2, 2, 714, 716,
	3, 2, 2, 2, 715, 701, 3, 2, 2, 2, 715, 711, 3, 2, 2, 2, 716, 89, 3, 2,
	2, 2, 717, 719, 7, 9, 2, 2, 718, 720, 7, 128, 2, 2, 719, 718, 3, 2, 2,
	2, 719, 720, 3, 2, 2, 2, 720, 725, 3, 2, 2, 2, 721, 723, 5, 178, 90, 2,
	722, 724, 7, 128, 2, 2, 723, 722, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724,
	726, 3, 2, 2, 2, 725, 721, 3, 2, 2, 2, 725, 726, 3, 2, 2, 2, 726, 731,
	3, 2, 2, 2, 727, 729, 5, 102, 52, 2, 728, 730, 7, 128, 2, 2, 729, 728,
	3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730, 732, 3, 2, 2, 2, 731, 727, 3, 2,
	2, 2, 731, 732, 3, 2, 2, 2, 732, 737, 3, 2, 2, 2, 733, 735, 5, 98, 50,
	2, 734, 736, 7, 128, 2, 2, 735, 734, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2,
	736, 738, 3, 2, 2, 2, 737, 733, 3, 2, 2, 2, 737, 738, 3, 2, 2, 2, 738,
	739, 3, 2, 2, 2, 739, 740, 7, 10, 2, 2, 740, 91, 3, 2, 2, 2, 741, 743,
	5, 94, 48, 2, 742, 744, 7, 128, 2, 2, 743, 742, 3, 2, 2, 2, 743, 744, 3,
	2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 746, 5, 90, 46, 2, 746, 93, 3, 2, 2,
	2, 747, 749, 5, 200, 101, 2, 748, 750, 7, 128, 2, 2, 749, 748, 3, 2, 2,
	2, 749, 750, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 753, 5, 204, 103, 2,
	752, 754, 7, 128, 2, 2, 753, 752, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754,
	756, 3, 2, 2, 2, 755, 757, 5, 96, 49, 2, 756, 755, 3, 2, 2, 2, 756, 757,
	3, 2, 2, 2, 757, 759, 3, 2, 2, 2, 758, 760, 7, 128, 2, 2, 759, 758, 3,
	2, 2, 2, 759, 760, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 763, 5, 204,
	103, 2, 762, 764, 7, 128, 2, 2, 763, 762, 3, 2, 2, 2, 763, 764, 3, 2, 2,
	2, 764, 765, 3, 2, 2, 2, 765, 766, 5, 202, 102, 2, 766, 812, 3, 2, 2, 2,
	767, 769, 5, 200, 101, 2, 768, 770, 7, 128, 2, 2, 769, 768, 3, 2, 2, 2,
	769, 770, 3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 773, 5, 204, 103, 2, 772,
	774, 7, 128, 2, 2, 773, 772, 3, 2, 2, 2, 773, 774, 3, 2, 2, 2, 774, 776,
	3, 2, 2, 2, 775, 777, 5, 96, 49, 2, 776, 775, 3, 2, 2, 2, 776, 777, 3,
	2, 2, 2, 777, 779, 3, 2, 2, 2, 778, 780, 7, 128, 2, 2, 779, 778, 3, 2,
	2, 2, 779, 780, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 782, 5, 204, 103,
	2, 782, 812, 3, 2, 2, 2, 783, 785, 5, 204, 103, 2, 784, 786, 7, 128, 2,
	2, 785, 784, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 788, 3, 2, 2, 2, 787,
	789, 5, 96, 49, 2, 788, 787, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2, 789, 791,
	3, 2, 2, 2, 790, 792, 7, 128, 2, 2, 791, 790, 3, 2, 2, 2, 791, 792, 3,
	2, 2, 2, 792, 793, 3, 2, 2, 2, 793, 795, 5, 204, 103, 2, 794, 796, 7, 128,
	2, 2, 795, 794, 3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 797, 3, 2, 2, 2,
	797, 798, 5, 202, 102, 2, 798, 812, 3, 2, 2, 2, 799, 801, 5, 204, 103,
	2, 800, 802, 7, 128, 2, 2, 801, 800, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2,
	802, 804, 3, 2, 2, 2, 803, 805, 5, 96, 49, 2, 804, 803, 3, 2, 2, 2, 804,
	805, 3, 2, 2, 2, 805, 807, 3, 2, 2, 2, 806, 808, 7, 128, 2, 2, 807, 806,
	3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 810, 5, 204,
	103, 2, 810, 812, 3, 2, 2, 2, 811, 747, 3, 2, 2, 2, 811, 767, 3, 2, 2,
	2, 811, 783, 3, 2, 2, 2, 811, 799, 3, 2, 2, 2, 812, 95, 3, 2, 2, 2, 813,
	815, 7, 11, 2, 2, 814, 816, 7, 128, 2, 2, 815, 814, 3, 2, 2, 2, 815, 816,
	3, 2, 2, 2, 816, 821, 3, 2, 2, 2, 817, 819, 5, 178, 90, 2, 818, 820, 7,
	128, 2, 2, 819, 818, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 822, 3, 2,
	2, 2, 821, 817, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 827, 3, 2, 2, 2,
	823, 825, 5, 100, 51, 2, 824, 826, 7, 128, 2, 2, 825, 824, 3, 2, 2, 2,
	825, 826, 3, 2, 2, 2, 826, 828, 3, 2, 2, 2, 827, 823, 3, 2, 2, 2, 827,
	828, 3, 2, 2, 2, 828, 830, 3, 2, 2, 2, 829, 831, 5, 106, 54, 2, 830, 829,
	3, 2, 2, 2, 830, 831, 3, 2, 2, 2, 831, 836, 3, 2, 2, 2, 832, 834, 5, 98,
	50, 2, 833, 835, 7, 128, 2, 2, 834, 833, 3, 2, 2, 2, 834, 835, 3, 2, 2,
	2, 835, 837, 3, 2, 2, 2, 836, 832, 3, 2, 2, 2, 836, 837, 3, 2, 2, 2, 837,
	838, 3, 2, 2, 2, 838, 839, 7, 12, 2, 2, 839, 97, 3, 2, 2, 2, 840, 843,
	5, 182, 92, 2, 841, 843, 5, 184, 93, 2, 842, 840, 3, 2, 2, 2, 842, 841,
	3, 2, 2, 2, 843, 99, 3, 2, 2, 2, 844, 846, 7, 13, 2, 2, 845, 847, 7, 128,
	2, 2, 846, 845, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 848, 3, 2, 2, 2,
	848, 862, 5, 110, 56, 2, 849, 851, 7, 128, 2, 2, 850, 849, 3, 2, 2, 2,
	850, 851, 3, 2, 2, 2, 851, 852, 3, 2, 2, 2, 852, 854, 7, 14, 2, 2, 853,
	855, 7, 13, 2, 2, 854, 853, 3, 2, 2, 2, 854, 855, 3, 2, 2, 2, 855, 857,
	3, 2, 2, 2, 856, 858, 7, 128, 2, 2, 857, 856, 3, 2, 2, 2, 857, 858, 3,
	2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 861, 5, 110, 56, 2, 860, 850, 3, 2,
	2, 2, 861, 864, 3, 2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2,
	863, 101, 3, 2, 2, 2, 864, 862, 3, 2, 2, 2, 865, 872, 5, 104, 53, 2, 866,
	868, 7, 128, 2, 2, 867, 866, 3, 2, 2, 2, 867, 868, 3, 2, 2, 2, 868, 869,
	3, 2, 2, 2, 869, 871, 5, 104, 53, 2, 870, 867, 3, 2, 2, 2, 871, 874, 3,
	2, 2, 2, 872, 870, 3, 2, 2, 2, 872, 873, 3, 2, 2, 2, 873, 103, 3, 2, 2,
	2, 874, 872, 3, 2, 2, 2, 875, 877, 7, 13, 2, 2, 876, 878, 7, 128, 2, 2,
	877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2, 879,
	880, 5, 108, 55, 2, 880, 105, 3, 2, 2, 2, 881, 883, 7, 8, 2, 2, 882, 884,
	7, 128, 2, 2, 883, 882, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 889, 3,
	2, 2, 2, 885, 887, 5, 190, 96, 2, 886, 888, 7, 128, 2, 2, 887, 886, 3,
	2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 890, 3, 2, 2, 2, 889, 885, 3, 2, 2,
	2, 889, 890, 3, 2, 2, 2, 890, 901, 3, 2, 2, 2, 891, 893, 7, 15, 2, 2, 892,
	894, 7, 128, 2, 2, 893, 892, 3, 2, 2, 2, 893, 894, 3, 2, 2, 2, 894, 899,
	3, 2, 2, 2, 895, 897, 5, 190, 96, 2, 896, 898, 7, 128, 2, 2, 897, 896,
	3, 2, 2, 2, 897, 898, 3, 2, 2, 2, 898, 900, 3, 2, 2, 2, 899, 895, 3, 2,
	2, 2, 899, 900, 3, 2, 2, 2, 900, 902, 3, 2, 2, 2, 901, 891, 3, 2, 2, 2,
	901, 902, 3, 2, 2, 2, 902, 107, 3, 2, 2, 2, 903, 904, 5, 194, 98, 2, 904,
	109, 3, 2, 2, 2, 905, 906, 5, 194, 98, 2, 906, 111, 3, 2, 2, 2, 907, 908,
	5, 114, 58, 2, 908, 113, 3, 2, 2, 2, 909, 916, 5, 116, 59, 2, 910, 911,
	7, 128, 2, 2, 911, 912, 7, 76, 2, 2, 912, 913, 7, 128, 2, 2, 913, 915,
	5, 116, 59, 2, 914, 910, 3, 2, 2, 2, 915, 918, 3, 2, 2, 2, 916, 914, 3,
	2, 2, 2, 916, 917, 3, 2, 2, 2, 917, 115, 3, 2, 2, 2, 918, 916, 3, 2, 2,
	2, 919, 926, 5, 118, 60, 2, 920, 921, 7, 128, 2, 2, 921, 922, 7, 77, 2,
	2, 922, 923, 7, 128, 2, 2, 923, 925, 5, 118, 60, 2, 924, 920, 3, 2, 2,
	2, 925, 928, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 926, 927, 3, 2, 2, 2, 927,
	117, 3, 2, 2, 2, 928, 926, 3, 2, 2, 2, 929, 936, 5, 120, 61, 2, 930, 931,
	7, 128, 2, 2, 931, 932, 7, 78, 2, 2, 932, 933, 7, 128, 2, 2, 933, 935,
	5, 120, 61, 2, 934, 930, 3, 2, 2, 2, 935, 938, 3, 2, 2, 2, 936, 934, 3,
	2, 2, 2, 936, 937, 3, 2, 2, 2, 937, 119, 3, 2, 2, 2, 938, 936, 3, 2, 2,
	2, 939, 941, 7, 79, 2, 2, 940, 942, 7, 128, 2, 2, 941, 940, 3, 2, 2, 2,
	941, 942, 3, 2, 2, 2, 942, 944, 3, 2, 2, 2, 943, 939, 3, 2, 2, 2, 944,
	947, 3, 2, 2, 2, 945, 943, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 948,
	3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 948, 949, 5, 122, 62, 2, 949, 121, 3,
	2, 2, 2, 950, 957, 5, 124, 63, 2, 951, 953, 7, 128, 2, 2, 952, 951, 3,
	2, 2, 2, 952, 953, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 956, 5, 144,
	73, 2, 955, 952, 3, 2, 2, 2, 956, 959, 3, 2, 2, 2, 957, 955, 3, 2, 2, 2,
	957, 958, 3, 2, 2, 2, 958, 123, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 960,
	979, 5, 126, 64, 2, 961, 963, 7, 128, 2, 2, 962, 961, 3, 2, 2, 2, 962,
	963, 3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 966, 7, 16, 2, 2, 965, 967,
	7, 128, 2, 2, 966, 965, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967, 968, 3,
	2, 2, 2, 968, 978, 5, 126, 64, 2, 969, 971, 7, 128, 2, 2, 970, 969, 3,
	2, 2, 2, 970, 971, 3, 2, 2, 2, 971, 972, 3, 2, 2, 2, 972, 974, 7, 7, 2,
	2, 973, 975, 7, 128, 2, 2, 974, 973, 3, 2, 2, 2, 974, 975, 3, 2, 2, 2,
	975, 976, 3, 2, 2, 2, 976, 978, 5, 126, 64, 2, 977, 962, 3, 2, 2, 2, 977,
	970, 3, 2, 2, 2, 978, 981, 3, 2, 2, 2, 979, 977, 3, 2, 2, 2, 979, 980,
	3, 2, 2, 2, 980, 125, 3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 982, 1009, 5, 128,
	65, 2, 983, 985, 7, 128, 2, 2, 984, 983, 3, 2, 2, 2, 984, 985, 3, 2, 2,
	2, 985, 986, 3, 2, 2, 2, 986, 988, 7, 8, 2, 2, 987, 989, 7, 128, 2, 2,
	988, 987, 3, 2, 2, 2, 988, 989, 3, 2, 2, 2, 989, 990, 3, 2, 2, 2, 990,
	1008, 5, 128, 65, 2, 991, 993, 7, 128, 2, 2, 992, 991, 3, 2, 2, 2, 992,
	993, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 996, 7, 17, 2, 2, 995, 997,
	7, 128, 2, 2, 996, 995, 3, 2, 2, 2, 996, 997, 3, 2, 2, 2, 997, 998, 3,
	2, 2, 2, 998, 1008, 5, 128, 65, 2, 999, 1001, 7, 128, 2, 2, 1000, 999,
	3, 2, 2, 2, 1000, 1001, 3, 2, 2, 2, 1001, 1002, 3, 2, 2, 2, 1002, 1004,
	7, 18, 2, 2, 1003, 1005, 7, 128, 2, 2, 1004, 1003, 3, 2, 2, 2, 1004, 1005,
	3, 2, 2, 2, 1005, 1006, 3, 2, 2, 2, 1006, 1008, 5, 128, 65, 2, 1007, 984,
	3, 2, 2, 2, 1007, 992, 3, 2, 2, 2, 1007, 1000, 3, 2, 2, 2, 1008, 1011,
	3, 2, 2, 2, 1009, 1007, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010, 127,
	3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1012, 1023, 5, 130, 66, 2, 1013, 1015,
	7, 128, 2, 2, 1014, 1013, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015, 1016,
	3, 2, 2, 2, 1016, 1018, 7, 19, 2, 2, 1017, 1019, 7, 128, 2, 2, 1018, 1017,
	3, 2, 2, 2, 1018, 1019, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 1022,
	5, 130, 66, 2, 1021, 1014, 3, 2, 2, 2, 1022, 1025, 3, 2, 2, 2, 1023, 1021,
	3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024, 129, 3, 2, 2, 2, 1025, 1023,
	3, 2, 2, 2, 1026, 1028, 9, 3, 2, 2, 1027, 1029, 7, 128, 2, 2, 1028, 1027,
	3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1031, 3, 2, 2, 2, 1030, 1026,
	3, 2, 2, 2, 1031, 1034, 3, 2, 2, 2, 1032, 1030, 3, 2, 2, 2, 1032, 1033,
	3, 2, 2, 2, 1033, 1035, 3, 2, 2, 2, 1034, 1032, 3, 2, 2, 2, 1035, 1036,
	5, 132, 67, 2, 1036, 131, 3, 2, 2, 2, 1037, 1091, 5, 134, 68, 2, 1038,
	1040, 7, 128, 2, 2, 1039, 1038, 3, 2, 2, 2, 1039, 1040, 3, 2, 2, 2, 1040,
	1041, 3, 2, 2, 2, 1041, 1042, 7, 11, 2, 2, 1042, 1043, 5, 112, 57, 2, 1043,
	1044, 7, 12, 2, 2, 1044, 1090, 3, 2, 2, 2, 1045, 1047, 7, 128, 2, 2, 1046,
	1045, 3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048,
	1050, 7, 11, 2, 2, 1049, 1051, 5, 112, 57, 2, 1050, 1049, 3, 2, 2, 2, 1050,
	1051, 3, 2, 2, 2, 1051, 1052, 3, 2, 2, 2, 1052, 1054, 7, 15, 2, 2, 1053,
	1055, 5, 112, 57, 2, 1054, 1053, 3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055,
	1056, 3, 2, 2, 2, 1056, 1090, 7, 12, 2, 2, 1057, 1059, 7, 128, 2, 2, 1058,
	1057, 3, 2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060,
	1074, 7, 20, 2, 2, 1061, 1062, 7, 128, 2, 2, 1062, 1074, 7, 80, 2, 2, 1063,
	1064, 7, 128, 2, 2, 1064, 1065, 7, 81, 2, 2, 1065, 1066, 7, 128, 2, 2,
	1066, 1074, 7, 64, 2, 2, 1067, 1068, 7, 128, 2, 2, 1068, 1069, 7, 82, 2,
	2, 1069, 1070, 7, 128, 2, 2, 1070, 1074, 7, 64, 2, 2, 1071, 1072, 7, 128,
	2, 2, 1072, 1074, 7, 83, 2, 2, 1073, 1058, 3, 2, 2, 2, 1073, 1061, 3, 2,
	2, 2, 1073, 1063, 3, 2, 2, 2, 1073, 1067, 3, 2, 2, 2, 1073, 1071, 3, 2,
	2, 2, 1074, 1076, 3, 2, 2, 2, 1075, 1077, 7, 128, 2, 2, 1076, 1075, 3,
	2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1078, 3, 2, 2, 2, 1078, 1090, 5,
	134, 68, 2, 1079, 1080, 7, 128, 2, 2, 1080, 1081, 7, 84, 2, 2, 1081, 1082,
	7, 128, 2, 2, 1082, 1090, 7, 85, 2, 2, 1083, 1084, 7, 128, 2, 2, 1084,
	1085, 7, 84, 2, 2, 1085, 1086, 7, 128, 2, 2, 1086, 1087, 7, 79, 2, 2, 1087,
	1088, 7, 128, 2, 2, 1088, 1090, 7, 85, 2, 2, 1089, 1039, 3, 2, 2, 2, 1089,
	1046, 3, 2, 2, 2, 1089, 1073, 3, 2, 2, 2, 1089, 1079, 3, 2, 2, 2, 1089,
	1083, 3, 2, 2, 2, 1090, 1093, 3, 2, 2, 2, 1091, 1089, 3, 2, 2, 2, 1091,
	1092, 3, 2, 2, 2, 1092, 133, 3, 2, 2, 2, 1093, 1091, 3, 2, 2, 2, 1094,
	1104, 5, 136, 69, 2, 1095, 1097, 7, 128, 2, 2, 1096, 1095, 3, 2, 2, 2,
	1096, 1097, 3, 2, 2, 2, 1097, 1100, 3, 2, 2, 2, 1098, 1101, 5, 172, 87,
	2, 1099, 1101, 5, 102, 52, 2, 1100, 1098, 3, 2, 2, 2, 1100, 1099, 3, 2,
	2, 2, 1101, 1103, 3, 2, 2, 2, 1102, 1096, 3, 2, 2, 2, 1103, 1106, 3, 2,
	2, 2, 1104, 1102, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 135, 3, 2,
	2, 2, 1106, 1104, 3, 2, 2, 2, 1107, 1221, 5, 138, 70, 2, 1108, 1221, 5,
	184, 93, 2, 1109, 1221, 5, 174, 88, 2, 1110, 1112, 7, 86, 2, 2, 1111, 1113,
	7, 128, 2, 2, 1112, 1111, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1114,
	3, 2, 2, 2, 1114, 1116, 7, 9, 2, 2, 1115, 1117, 7, 128, 2, 2, 1116, 1115,
	3, 2, 2, 2, 1116, 1117, 3, 2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1120,
	7, 8, 2, 2, 1119, 1121, 7, 128, 2, 2, 1120, 1119, 3, 2, 2, 2, 1120, 1121,
	3, 2, 2, 2, 1121, 1122, 3, 2, 2, 2, 1122, 1221, 7, 10, 2, 2, 1123, 1221,
	5, 168, 85, 2, 1124, 1221, 5, 170, 86, 2, 1125, 1127, 7, 87, 2, 2, 1126,
	1128, 7, 128, 2, 2, 1127, 1126, 3, 2, 2, 2, 1127, 1128, 3, 2, 2, 2, 1128,
	1129, 3, 2, 2, 2, 1129, 1131, 7, 9, 2, 2, 1130, 1132, 7, 128, 2, 2, 1131,
	1130, 3, 2, 2, 2, 1131, 1132, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133,
	1135, 5, 150, 76, 2, 1134, 1136, 7, 128, 2, 2, 1135, 1134, 3, 2, 2, 2,
	1135, 1136, 3, 2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137, 1138, 7, 10, 2, 2,
	1138, 1221, 3, 2, 2, 2, 1139, 1141, 7, 88, 2, 2, 1140, 1142, 7, 128, 2,
	2, 1141, 1140, 3, 2, 2, 2, 1141, 1142, 3, 2, 2, 2, 1142, 1143, 3, 2, 2,
	2, 1143, 1145, 7, 9, 2, 2, 1144, 1146, 7, 128, 2, 2, 1145, 1144, 3, 2,
	2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 1147, 3, 2, 2, 2, 1147, 1149, 5, 150,
	76, 2, 1148, 1150, 7, 128, 2, 2, 1149, 1148, 3, 2, 2, 2, 1149, 1150, 3,
	2, 2, 2, 1150, 1156, 3, 2, 2, 2, 1151, 1153, 7, 128, 2, 2, 1152, 1151,
	3, 2, 2, 2, 1152, 1153, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2, 1154, 1155,
	7, 14, 2, 2, 1155, 1157, 5, 112, 57, 2, 1156, 1152, 3, 2, 2, 2, 1156, 1157,
	3, 2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1159, 7, 10, 2, 2, 1159, 1221,
	3, 2, 2, 2, 1160, 1162, 7, 50, 2, 2, 1161, 1163, 7, 128, 2, 2, 1162, 1161,
	3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1164, 3, 2, 2, 2, 1164, 1166,
	7, 9, 2, 2, 1165, 1167, 7, 128, 2, 2, 1166, 1165, 3, 2, 2, 2, 1166, 1167,
	3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2, 1168, 1170, 5, 150, 76, 2, 1169, 1171,
	7, 128, 2, 2, 1170, 1169, 3, 2, 2, 2, 1170, 1171, 3, 2, 2, 2, 1171, 1172,
	3, 2, 2, 2, 1172, 1173, 7, 10, 2, 2, 1173, 1221, 3, 2, 2, 2, 1174, 1176,
	7, 89, 2, 2, 1175, 1177, 7, 128, 2, 2, 1176, 1175, 3, 2, 2, 2, 1176, 1177,
	3, 2, 2, 2, 1177, 1178, 3, 2, 2, 2, 1178, 1180, 7, 9, 2, 2, 1179, 1181,
	7, 128, 2, 2, 1180, 1179, 3, 2, 2, 2, 1180, 1181, 3, 2, 2, 2, 1181, 1182,
	3, 2, 2, 2, 1182, 1184, 5, 150, 76, 2, 1183, 1185, 7, 128, 2, 2, 1184,
	1183, 3, 2, 2, 2, 1184, 1185, 3, 2, 2, 2, 1185, 1186, 3, 2, 2, 2, 1186,
	1187, 7, 10, 2, 2, 1187, 1221, 3, 2, 2, 2, 1188, 1190, 7, 90, 2, 2, 1189,
	1191, 7, 128, 2, 2, 1190, 1189, 3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191,
	1192, 3, 2, 2, 2, 1192, 1194, 7, 9, 2, 2, 1193, 1195, 7, 128, 2, 2, 1194,
	1193, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196,
	1198, 5, 150, 76, 2, 1197, 1199, 7, 128, 2, 2, 1198, 1197, 3, 2, 2, 2,
	1198, 1199, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1201, 7, 10, 2, 2,
	1201, 1221, 3, 2, 2, 2, 1202, 1204, 7, 91, 2, 2, 1203, 1205, 7, 128, 2,
	2, 1204, 1203, 3, 2, 2, 2, 1204, 1205, 3, 2, 2, 2, 1205, 1206, 3, 2, 2,
	2, 1206, 1208, 7, 9, 2, 2, 1207, 1209, 7, 128, 2, 2, 1208, 1207, 3, 2,
	2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1210, 3, 2, 2, 2, 1210, 1212, 5, 150,
	76, 2, 1211, 1213, 7, 128, 2, 2, 1212, 1211, 3, 2, 2, 2, 1212, 1213, 3,
	2, 2, 2, 1213, 1214, 3, 2, 2, 2, 1214, 1215, 7, 10, 2, 2, 1215, 1221, 3,
	2, 2, 2, 1216, 1221, 5, 148, 75, 2, 1217, 1221, 5, 146, 74, 2, 1218, 1221,
	5, 154, 78, 2, 1219, 1221, 5, 178, 90, 2, 1220, 1107, 3, 2, 2, 2, 1220,
	1108, 3, 2, 2, 2, 1220, 1109, 3, 2, 2, 2, 1220, 1110, 3, 2, 2, 2, 1220,
	1123, 3, 2, 2, 2, 1220, 1124, 3, 2, 2, 2, 1220, 1125, 3, 2, 2, 2, 1220,
	1139, 3, 2, 2, 2, 1220, 1160, 3, 2, 2, 2, 1220, 1174, 3, 2, 2, 2, 1220,
	1188, 3, 2, 2, 2, 1220, 1202, 3, 2, 2, 2, 1220, 1216, 3, 2, 2, 2, 1220,
	1217, 3, 2, 2, 2, 1220, 1218, 3, 2, 2, 2, 1220, 1219, 3, 2, 2, 2, 1221,
	137, 3, 2, 2, 2, 1222, 1229, 5, 180, 91, 2, 1223, 1229, 7, 100, 2, 2, 1224,
	1229, 5, 140, 71, 2, 1225, 1229, 7, 85, 2, 2, 1226, 1229, 5, 182, 92, 2,
	1227, 1229, 5, 142, 72, 2, 1228, 1222, 3, 2, 2, 2, 1228, 1223, 3, 2, 2,
	2, 1228, 1224, 3, 2, 2, 2, 1228, 1225, 3, 2, 2, 2, 1228, 1226, 3, 2, 2,
	2, 1228, 1227, 3, 2, 2, 2, 1229, 139, 3, 2, 2, 2, 1230, 1231, 9, 4, 2,
	2, 1231, 141, 3, 2, 2, 2, 1232, 1234, 7, 11, 2, 2, 1233, 1235, 7, 128,
	2, 2, 1234, 1233, 3, 2, 2, 2, 1234, 1235, 3, 2, 2, 2, 1235, 1253, 3, 2,
	2, 2, 1236, 1238, 5, 112, 57, 2, 1237, 1239, 7, 128, 2, 2, 1238, 1237,
	3, 2, 2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 1250, 3, 2, 2, 2, 1240, 1242,
	7, 4, 2, 2, 1241, 1243, 7, 128, 2, 2, 1242, 1241, 3, 2, 2, 2, 1242, 1243,
	3, 2, 2, 2, 1243, 1244, 3, 2, 2, 2, 1244, 1246, 5, 112, 57, 2, 1245, 1247,
	7, 128, 2, 2, 1246, 1245, 3, 2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 1249,
	3, 2, 2, 2, 1248, 1240, 3, 2, 2, 2, 1249, 1252, 3, 2, 2, 2, 1250, 1248,
	3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1254, 3, 2, 2, 2, 1252, 1250,
	3, 2, 2, 2, 1253, 1236, 3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254, 1255,
	3, 2, 2, 2, 1255, 1256, 7, 12, 2, 2, 1256, 143, 3, 2, 2, 2, 1257, 1259,
	7, 5, 2, 2, 1258, 1260, 7, 128, 2, 2, 1259, 1258, 3, 2, 2, 2, 1259, 1260,
	3, 2, 2, 2, 1260, 1261, 3, 2, 2, 2, 1261, 1288, 5, 124, 63, 2, 1262, 1264,
	7, 21, 2, 2, 1263, 1265, 7, 128, 2, 2, 1264, 1263, 3, 2, 2, 2, 1264, 1265,
	3, 2, 2, 2, 1265, 1266, 3, 2, 2, 2, 1266, 1288, 5, 124, 63, 2, 1267, 1269,
	7, 22, 2, 2, 1268, 1270, 7, 128, 2, 2, 1269, 1268, 3, 2, 2, 2, 1269, 1270,
	3, 2, 2, 2, 1270, 1271, 3, 2, 2, 2, 1271, 1288, 5, 124, 63, 2, 1272, 1274,
	7, 23, 2, 2, 1273, 1275, 7, 128, 2, 2, 1274, 1273, 3, 2, 2, 2, 1274, 1275,
	3, 2, 2, 2, 1275, 1276, 3, 2, 2, 2, 1276, 1288, 5, 124, 63, 2, 1277, 1279,
	7, 24, 2, 2, 1278, 1280, 7, 128, 2, 2, 1279, 1278, 3, 2, 2, 2, 1279, 1280,
	3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2, 1281, 1288, 5, 124, 63, 2, 1282, 1284,
	7, 25, 2, 2, 1283, 1285, 7, 128, 2, 2, 1284, 1283, 3, 2, 2, 2, 1284, 1285,
	3, 2, 2, 2, 1285, 1286, 3, 2, 2, 2, 1286, 1288, 5, 124, 63, 2, 1287, 1257,
	3, 2, 2, 2, 1287, 1262, 3, 2, 2, 2, 1287, 1267, 3, 2, 2, 2, 1287, 1272,
	3, 2, 2, 2, 1287, 1277, 3, 2, 2, 2, 1287, 1282, 3, 2, 2, 2, 1288, 145,
	3, 2, 2, 2, 1289, 1291, 7, 9, 2, 2, 1290, 1292, 7, 128, 2, 2, 1291, 1290,
	3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1293, 3, 2, 2, 2, 1293, 1295,
	5, 112, 57, 2, 1294, 1296, 7, 128, 2, 2, 1295, 1294, 3, 2, 2, 2, 1295,
	1296, 3, 2, 2, 2, 1296, 1297, 3, 2, 2, 2, 1297, 1298, 7, 10, 2, 2, 1298,
	147, 3, 2, 2, 2, 1299, 1304, 5, 90, 46, 2, 1300, 1302, 7, 128, 2, 2, 1301,
	1300, 3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1303, 3, 2, 2, 2, 1303,
	1305, 5, 92, 47, 2, 1304, 1301, 3, 2, 2, 2, 1305, 1306, 3, 2, 2, 2, 1306,
	1304, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307, 149, 3, 2, 2, 2, 1308,
	1313, 5, 152, 77, 2, 1309, 1311, 7, 128, 2, 2, 1310, 1309, 3, 2, 2, 2,
	1310, 1311, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1314, 5, 80, 41,
	2, 1313, 1310, 3, 2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 151, 3, 2, 2,
	2, 1315, 1316, 5, 178, 90, 2, 1316, 1317, 7, 128, 2, 2, 1317, 1318, 7,
	80, 2, 2, 1318, 1319, 7, 128, 2, 2, 1319, 1320, 5, 112, 57, 2, 1320, 153,
	3, 2, 2, 2, 1321, 1323, 5, 156, 79, 2, 1322, 1324, 7, 128, 2, 2, 1323,
	1322, 3, 2, 2, 2, 1323, 1324, 3, 2, 2, 2, 1324, 1325, 3, 2, 2, 2, 1325,
	1327, 7, 9, 2, 2, 1326, 1328, 7, 128, 2, 2, 1327, 1326, 3, 2, 2, 2, 1327,
	1328, 3, 2, 2, 2, 1328, 1333, 3, 2, 2, 2, 1329, 1331, 7, 65, 2, 2, 1330,
	1332, 7, 128, 2, 2, 1331, 1330, 3, 2, 2, 2, 1331, 1332, 3, 2, 2, 2, 1332,
	1334, 3, 2, 2, 2, 1333, 1329, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334,
	1352, 3, 2, 2, 2, 1335, 1337, 5, 112, 57, 2, 1336, 1338, 7, 128, 2, 2,
	1337, 1336, 3, 2, 2, 2, 1337, 1338, 3, 2, 2, 2, 1338, 1349, 3, 2, 2, 2,
	1339, 1341, 7, 4, 2, 2, 1340, 1342, 7, 128, 2, 2, 1341, 1340, 3, 2, 2,
	2, 1341, 1342, 3, 2, 2, 2, 1342, 1343, 3, 2, 2, 2, 1343, 1345, 5, 112,
	57, 2, 1344, 1346, 7, 128, 2, 2, 1345, 1344, 3, 2, 2, 2, 1345, 1346, 3,
	2, 2, 2, 1346, 1348, 3, 2, 2, 2, 1347, 1339, 3, 2, 2, 2, 1348, 1351, 3,
	2, 2, 2, 1349, 1347, 3, 2, 2, 2, 1349, 1350, 3, 2, 2, 2, 1350, 1353, 3,
	2, 2, 2, 1351, 1349, 3, 2, 2, 2, 1352, 1335, 3, 2, 2, 2, 1352, 1353, 3,
	2, 2, 2, 1353, 1354, 3, 2, 2, 2, 1354, 1355, 7, 10, 2, 2, 1355, 155, 3,
	2, 2, 2, 1356, 1359, 5, 198, 100, 2, 1357, 1359, 7, 94, 2, 2, 1358, 1356,
	3, 2, 2, 2, 1358, 1357, 3, 2, 2, 2, 1359, 157, 3, 2, 2, 2, 1360, 1362,
	5, 164, 83, 2, 1361, 1363, 7, 128, 2, 2, 1362, 1361, 3, 2, 2, 2, 1362,
	1363, 3, 2, 2, 2, 1363, 1364, 3, 2, 2, 2, 1364, 1366, 7, 9, 2, 2, 1365,
	1367, 7, 128, 2, 2, 1366, 1365, 3, 2, 2, 2, 1366, 1367, 3, 2, 2, 2, 1367,
	1385, 3, 2, 2, 2, 1368, 1370, 5, 112, 57, 2, 1369, 1371, 7, 128, 2, 2,
	1370, 1369, 3, 2, 2, 2, 1370, 1371, 3, 2, 2, 2, 1371, 1382, 3, 2, 2, 2,
	1372, 1374, 7, 4, 2, 2, 1373, 1375, 7, 128, 2, 2, 1374, 1373, 3, 2, 2,
	2, 1374, 1375, 3, 2, 2, 2, 1375, 1376, 3, 2, 2, 2, 1376, 1378, 5, 112,
	57, 2, 1377, 1379, 7, 128, 2, 2, 1378, 1377, 3, 2, 2, 2, 1378, 1379, 3,
	2, 2, 2, 1379, 1381, 3, 2, 2, 2, 1380, 1372, 3, 2, 2, 2, 1381, 1384, 3,
	2, 2, 2, 1382, 1380, 3, 2, 2, 2, 1382, 1383, 3, 2, 2, 2, 1383, 1386, 3,
	2, 2, 2, 1384, 1382, 3, 2, 2, 2, 1385, 1368, 3, 2, 2, 2, 1385, 1386, 3,
	2, 2, 2, 1386, 1387, 3, 2, 2, 2, 1387, 1388, 7, 10, 2, 2, 1388, 159, 3,
	2, 2, 2, 1389, 1390, 5, 164, 83, 2, 1390, 161, 3, 2, 2, 2, 1391, 1392,
	5, 198, 100, 2, 1392, 163, 3, 2, 2, 2, 1393, 1394, 5, 166, 84, 2, 1394,
	1395, 5, 198, 100, 2, 1395, 165, 3, 2, 2, 2, 1396, 1397, 5, 198, 100, 2,
	1397, 1398, 7, 26, 2, 2, 1398, 1400, 3, 2, 2, 2, 1399, 1396, 3, 2, 2, 2,
	1400, 1403, 3, 2, 2, 2, 1401, 1399, 3, 2, 2, 2, 1401, 1402, 3, 2, 2, 2,
	1402, 167, 3, 2, 2, 2, 1403, 1401, 3, 2, 2, 2, 1404, 1406, 7, 11, 2, 2,
	1405, 1407, 7, 128, 2, 2, 1406, 1405, 3, 2, 2, 2, 1406, 1407, 3, 2, 2,
	2, 1407, 1408, 3, 2, 2, 2, 1408, 1417, 5, 150, 76, 2, 1409, 1411, 7, 128,
	2, 2, 1410, 1409, 3, 2, 2, 2, 1410, 1411, 3, 2, 2, 2, 1411, 1412, 3, 2,
	2, 2, 1412, 1414, 7, 14, 2, 2, 1413, 1415, 7, 128, 2, 2, 1414, 1413, 3,
	2, 2, 2, 1414, 1415, 3, 2, 2, 2, 1415, 1416, 3, 2, 2, 2, 1416, 1418, 5,
	112, 57, 2, 1417, 1410, 3, 2, 2, 2, 1417, 1418, 3, 2, 2, 2, 1418, 1420,
	3, 2, 2, 2, 1419, 1421, 7, 128, 2, 2, 1420, 1419, 3, 2, 2, 2, 1420, 1421,
	3, 2, 2, 2, 1421, 1422, 3, 2, 2, 2, 1422, 1423, 7, 12, 2, 2, 1423, 169,
	3, 2, 2, 2, 1424, 1426, 7, 11, 2, 2, 1425, 1427, 7, 128, 2, 2, 1426, 1425,
	3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427, 1436, 3, 2, 2, 2, 1428, 1430,
	5, 178, 90, 2, 1429, 1431, 7, 128, 2, 2, 1430, 1429, 3, 2, 2, 2, 1430,
	1431, 3, 2, 2, 2, 1431, 1432, 3, 2, 2, 2, 1432, 1434, 7, 5, 2, 2, 1433,
	1435, 7, 128, 2, 2, 1434, 1433, 3, 2, 2, 2, 1434, 1435, 3, 2, 2, 2, 1435,
	1437, 3, 2, 2, 2, 1436, 1428, 3, 2, 2, 2, 1436, 1437, 3, 2, 2, 2, 1437,
	1438, 3, 2, 2, 2, 1438, 1440, 5, 148, 75, 2, 1439, 1441, 7, 128, 2, 2,
	1440, 1439, 3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1450, 3, 2, 2, 2,
	1442, 1444, 7, 75, 2, 2, 1443, 1445, 7, 128, 2, 2, 1444, 1443, 3, 2, 2,
	2, 1444, 1445, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 1448, 5, 112,
	57, 2, 1447, 1449, 7, 128, 2, 2, 1448, 1447, 3, 2, 2, 2, 1448, 1449, 3,
	2, 2, 2, 1449, 1451, 3, 2, 2, 2, 1450, 1442, 3, 2, 2, 2, 1450, 1451, 3,
	2, 2, 2, 1451, 1452, 3, 2, 2, 2, 1452, 1454, 7, 14, 2, 2, 1453, 1455, 7,
	128, 2, 2, 1454, 1453, 3, 2, 2, 2, 1454, 1455, 3, 2, 2, 2, 1455, 1456,
	3, 2, 2, 2, 1456, 1458, 5, 112, 57, 2, 1457, 1459, 7, 128, 2, 2, 1458,
	1457, 3, 2, 2, 2, 1458, 1459, 3, 2, 2, 2, 1459, 1460, 3, 2, 2, 2, 1460,
	1461, 7, 12, 2, 2, 1461, 171, 3, 2, 2, 2, 1462, 1464, 7, 26, 2, 2, 1463,
	1465, 7, 128, 2, 2, 1464, 1463, 3, 2, 2, 2, 1464, 1465, 3, 2, 2, 2, 1465,
	1466, 3, 2, 2, 2, 1466, 1467, 5, 188, 95, 2, 1467, 173, 3, 2, 2, 2, 1468,
	1473, 7, 95, 2, 2, 1469, 1471, 7, 128, 2, 2, 1470, 1469, 3, 2, 2, 2, 1470,
	1471, 3, 2, 2, 2, 1471, 1472, 3, 2, 2, 2, 1472, 1474, 5, 176, 89, 2, 1473,
	1470, 3, 2, 2, 2, 1474, 1475, 3, 2, 2, 2, 1475, 1473, 3, 2, 2, 2, 1475,
	1476, 3, 2, 2, 2, 1476, 1491, 3, 2, 2, 2, 1477, 1479, 7, 95, 2, 2, 1478,
	1480, 7, 128, 2, 2, 1479, 1478, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480,
	1481, 3, 2, 2, 2, 1481, 1486, 5, 112, 57, 2, 1482, 1484, 7, 128, 2, 2,
	1483, 1482, 3, 2, 2, 2, 1483, 1484, 3, 2, 2, 2, 1484, 1485, 3, 2, 2, 2,
	1485, 1487, 5, 176, 89, 2, 1486, 1483, 3, 2, 2, 2, 1487, 1488, 3, 2, 2,
	2, 1488, 1486, 3, 2, 2, 2, 1488, 1489, 3, 2, 2, 2, 1489, 1491, 3, 2, 2,
	2, 1490, 1468, 3, 2, 2, 2, 1490, 1477, 3, 2, 2, 2, 1491, 1500, 3, 2, 2,
	2, 1492, 1494, 7, 128, 2, 2, 1493, 1492, 3, 2, 2, 2, 1493, 1494, 3, 2,
	2, 2, 1494, 1495, 3, 2, 2, 2, 1495, 1497, 7, 96, 2, 2, 1496, 1498, 7, 128,
	2, 2, 1497, 1496, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498, 1499, 3, 2,
	2, 2, 1499, 1501, 5, 112, 57, 2, 1500, 1493, 3, 2, 2, 2, 1500, 1501, 3,
	2, 2, 2, 1501, 1503, 3, 2, 2, 2, 1502, 1504, 7, 128, 2, 2, 1503, 1502,
	3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1505, 3, 2, 2, 2, 1505, 1506,
	7, 97, 2, 2, 1506, 175, 3, 2, 2, 2, 1507, 1509, 7, 98, 2, 2, 1508, 1510,
	7, 128, 2, 2, 1509, 1508, 3, 2, 2, 2, 1509, 1510, 3, 2, 2, 2, 1510, 1511,
	3, 2, 2, 2, 1511, 1513, 5, 112, 57, 2, 1512, 1514, 7, 128, 2, 2, 1513,
	1512, 3, 2, 2, 2, 1513, 1514, 3, 2, 2, 2, 1514, 1515, 3, 2, 2, 2, 1515,
	1517, 7, 99, 2, 2, 1516, 1518, 7, 128, 2, 2, 1517, 1516, 3, 2, 2, 2, 1517,
	1518, 3, 2, 2, 2, 1518, 1519, 3, 2, 2, 2, 1519, 1520, 5, 112, 57, 2, 1520,
	177, 3, 2, 2, 2, 1521, 1522, 5, 198, 100, 2, 1522, 179, 3, 2, 2, 2, 1523,
	1526, 5, 192, 97, 2, 1524, 1526, 5, 190, 96, 2, 1525, 1523, 3, 2, 2, 2,
	1525, 1524, 3, 2, 2, 2, 1526, 181, 3, 2, 2, 2, 1527, 1529, 7, 27, 2, 2,
	1528, 1530, 7, 128, 2, 2, 1529, 1528, 3, 2, 2, 2, 1529, 1530, 3, 2, 2,
	2, 1530, 1564, 3, 2, 2, 2, 1531, 1533, 5, 188, 95, 2, 1532, 1534, 7, 128,
	2, 2, 1533, 1532, 3, 2, 2, 2, 1533, 1534, 3, 2, 2, 2, 1534, 1535, 3, 2,
	2, 2, 1535, 1537, 7, 13, 2, 2, 1536, 1538, 7, 128, 2, 2, 1537, 1536, 3,
	2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1541, 5,
	112, 57, 2, 1540, 1542, 7, 128, 2, 2, 1541, 1540, 3, 2, 2, 2, 1541, 1542,
	3, 2, 2, 2, 1542, 1561, 3, 2, 2, 2, 1543, 1545, 7, 4, 2, 2, 1544, 1546,
	7, 128, 2, 2, 1545, 1544, 3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546, 1547,
	3, 2, 2, 2, 1547, 1549, 5, 188, 95, 2, 1548, 1550, 7, 128, 2, 2, 1549,
	1548, 3, 2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 1551, 3, 2, 2, 2, 1551,
	1553, 7, 13, 2, 2, 1552, 1554, 7, 128, 2, 2, 1553, 1552, 3, 2, 2, 2, 1553,
	1554, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 1557, 5, 112, 57, 2, 1556,
	1558, 7, 128, 2, 2, 1557, 1556, 3, 2, 2, 2, 1557, 1558, 3, 2, 2, 2, 1558,
	1560, 3, 2, 2, 2, 1559, 1543, 3, 2, 2, 2, 1560, 1563, 3, 2, 2, 2, 1561,
	1559, 3, 2, 2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1565, 3, 2, 2, 2, 1563,
	1561, 3, 2, 2, 2, 1564, 1531, 3, 2, 2, 2, 1564, 1565, 3, 2, 2, 2, 1565,
	1566, 3, 2, 2, 2, 1566, 1567, 7, 28, 2, 2, 1567, 183, 3, 2, 2, 2, 1568,
	1571, 7, 29, 2, 2, 1569, 1572, 5, 198, 100, 2, 1570, 1572, 7, 103, 2, 2,
	1571, 1569, 3, 2, 2, 2, 1571, 1570, 3, 2, 2, 2, 1572, 185, 3, 2, 2, 2,
	1573, 1578, 5, 136, 69, 2, 1574, 1576, 7, 128, 2, 2, 1575, 1574, 3, 2,
	2, 2, 1575, 1576, 3, 2, 2, 2, 1576, 1577, 3, 2, 2, 2, 1577, 1579, 5, 172,
	87, 2, 1578, 1575, 3, 2, 2, 2, 1579, 1580, 3, 2, 2, 2, 1580, 1578, 3, 2,
	2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 187, 3, 2, 2, 2, 1582, 1583, 5, 194,
	98, 2, 1583, 189, 3, 2, 2, 2, 1584, 1585, 9, 5, 2, 2, 1585, 191, 3, 2,
	2, 2, 1586, 1587, 9, 6, 2, 2, 1587, 193, 3, 2, 2, 2, 1588, 1591, 5, 198,
	100, 2, 1589, 1591, 5, 196, 99, 2, 1590, 1588, 3, 2, 2, 2, 1590, 1589,
	3, 2, 2, 2, 1591, 195, 3, 2, 2, 2, 1592, 1593, 9, 7, 2, 2, 1593, 197, 3,
	2, 2, 2, 1594, 1595, 9, 8, 2, 2, 1595, 199, 3, 2, 2, 2, 1596, 1597, 9,
	9, 2, 2, 1597, 201, 3, 2, 2, 2, 1598, 1599, 9, 10, 2, 2, 1599, 203, 3,
	2, 2, 2, 1600, 1601, 9, 11, 2, 2, 1601, 205, 3, 2, 2, 2, 296, 207, 211,
	214, 217, 225, 229, 234, 241, 246, 249, 253, 258, 265, 270, 274, 279, 282,
	285, 289, 294, 298, 301, 306, 310, 314, 320, 324, 331, 335, 340, 344, 349,
	356, 361, 365, 369, 373, 376, 380, 390, 397, 410, 414, 420, 427, 432, 436,
	442, 446, 452, 456, 462, 466, 470, 474, 478, 482, 487, 494, 498, 503, 510,
	516, 521, 527, 533, 537, 541, 546, 550, 557, 563, 566, 571, 574, 578, 581,
	589, 593, 597, 601, 605, 610, 615, 619, 624, 627, 636, 645, 650, 663, 666,
	674, 678, 683, 688, 692, 697, 703, 708, 715, 719, 723, 725, 729, 731, 735,
	737, 743, 749, 753, 756, 759, 763, 769, 773, 776, 779, 785, 788, 791, 795,
	801, 804, 807, 811, 815, 819, 821, 825, 827, 830, 834, 836, 842, 846, 850,
	854, 857, 862, 867, 872, 877, 883, 887, 889, 893, 897, 899, 901, 916, 926,
	936, 941, 945, 952, 957, 962, 966, 970, 974, 977, 979, 984, 988, 992, 996,
	1000, 1004, 1007, 1009, 1014, 1018, 1023, 1028, 1032, 1039, 1046, 1050,
	1054, 1058, 1073, 1076, 1089, 1091, 1096, 1100, 1104, 1112, 1116, 1120,
	1127, 1131, 1135, 1141, 1145, 1149, 1152, 1156, 1162, 1166, 1170, 1176,
	1180, 1184, 1190, 1194, 1198, 1204, 1208, 1212, 1220, 1228, 1234, 1238,
	1242, 1246, 1250, 1253, 1259, 1264, 1269, 1274, 1279, 1284, 1287, 1291,
	1295, 1301, 1306, 1310, 1313, 1323, 1327, 1331, 1333, 1337, 1341, 1345,
	1349, 1352, 1358, 1362, 1366, 1370, 1374, 1378, 1382, 1385, 1401, 1406,
	1410, 1414, 1417, 1420, 1426, 1430, 1434, 1436, 1440, 1444, 1448, 1450,
	1454, 1458, 1464, 1470, 1475, 1479, 1483, 1488, 1490, 1493, 1497, 1500,
	1503, 1509, 1513, 1517, 1525, 1529, 1533, 1537, 1541, 1545, 1549, 1553,
	1557, 1561, 1564, 1571, 1575, 1580, 1590,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "','", "'='", "'+='", "'-'", "'*'", "'('", "')'", "'['", "']'",
	"':'", "'|'", "'..'", "'+'", "'/'", "'%'", "'^'", "'=~'", "'<>'", "'<'",
	"'>'", "'<='", "'>='", "'.'", "'{'", "'}'", "'$'", "'\u00E2\u0178\u00A8'",
	"'\u00E3\u20AC\u02C6'", "'\u00EF\u00B9\u00A4'", "'\u00EF\u00BC\u0153'",
	"'\u00E2\u0178\u00A9'", "'\u00E3\u20AC\u2030'", "'\u00EF\u00B9\u00A5'",
	"'\u00EF\u00BC\u017E'", "'\u00C2\u00AD'", "'\u00E2\u20AC\uFFFD'", "'\u00E2\u20AC\u2018'",
	"'\u00E2\u20AC\u2019'", "'\u00E2\u20AC\u201C'", "'\u00E2\u20AC\u201D'",
	"'\u00E2\u20AC\u2022'", "'\u00E2\u02C6\u2019'", "'\u00EF\u00B9\u02DC'",
	"'\u00EF\u00B9\u00A3'", "'\u00EF\u00BC\uFFFD'", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "'0'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "UNION", "ALL", "OPTIONAL",
	"MATCH", "UNWIND", "AS", "MERGE", "ON", "CREATE", "SET", "DETACH", "DELETE",
	"REMOVE", "CALL", "YIELD", "WITH", "DISTINCT", "RETURN", "ORDER", "BY",
	"L_SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "WHERE", "OR",
	"XOR", "AND", "NOT", "IN", "STARTS", "ENDS", "CONTAINS", "IS", "NULL",
	"COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE",
	"EXISTS", "CASE", "ELSE", "END", "WHEN", "THEN", "StringLiteral", "EscapedChar",
	"HexInteger", "DecimalInteger", "OctalInteger", "HexLetter", "HexDigit",
	"Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", "ExponentDecimalReal",
	"RegularDecimalReal", "CONSTRAINT", "DO", "FOR", "REQUIRE", "UNIQUE", "MANDATORY",
	"SCALAR", "OF", "ADD", "DROP", "UnescapedSymbolicName", "IdentifierStart",
	"IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE", "Comment",
}

var ruleNames = []string{
	"cypher", "statement", "query", "regularQuery", "union", "singleQuery",
	"singlePartQuery", "readOnlyEnd", "readUpdateEnd", "updatingEnd", "multiPartQuery",
	"readPart", "updatingPart", "updatingStartClause", "updatingClause", "readingClause",
	"match", "unwind", "merge", "mergeAction", "create", "set", "setItem",
	"delete", "remove", "removeItem", "inQueryCall", "standaloneCall", "yieldItems",
	"yieldItem", "with", "return", "returnBody", "returnItems", "returnItem",
	"order", "skip", "limit", "sortItem", "where", "pattern", "patternPart",
	"anonymousPatternPart", "patternElement", "nodePattern", "patternElementChain",
	"relationshipPattern", "relationshipDetail", "properties", "relationshipTypes",
	"nodeLabels", "nodeLabel", "rangeLiteral", "labelName", "relTypeName",
	"expression", "orExpression", "xorExpression", "andExpression", "notExpression",
	"comparisonExpression", "addOrSubtractExpression", "multiplyDivideModuloExpression",
	"powerOfExpression", "unaryAddOrSubtractExpression", "stringListNullOperatorExpression",
	"propertyOrLabelsExpression", "atom", "literal", "booleanLiteral", "listLiteral",
	"partialComparisonExpression", "parenthesizedExpression", "relationshipsPattern",
	"filterExpression", "idInColl", "functionInvocation", "functionName", "explicitProcedureInvocation",
	"implicitProcedureInvocation", "procedureResultField", "procedureName",
	"namespace", "listComprehension", "patternComprehension", "propertyLookup",
	"caseExpression", "caseAlternatives", "variable", "numberLiteral", "mapLiteral",
	"parameter", "propertyExpression", "propertyKeyName", "integerLiteral",
	"doubleLiteral", "schemaName", "reservedWord", "symbolicName", "leftArrowHead",
	"rightArrowHead", "dash",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type CypherParser struct {
	*antlr.BaseParser
}

func NewCypherParser(input antlr.TokenStream) *CypherParser {
	this := new(CypherParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Cypher.g4"

	return this
}

// CypherParser tokens.
const (
	CypherParserEOF                   = antlr.TokenEOF
	CypherParserT__0                  = 1
	CypherParserT__1                  = 2
	CypherParserT__2                  = 3
	CypherParserT__3                  = 4
	CypherParserT__4                  = 5
	CypherParserT__5                  = 6
	CypherParserT__6                  = 7
	CypherParserT__7                  = 8
	CypherParserT__8                  = 9
	CypherParserT__9                  = 10
	CypherParserT__10                 = 11
	CypherParserT__11                 = 12
	CypherParserT__12                 = 13
	CypherParserT__13                 = 14
	CypherParserT__14                 = 15
	CypherParserT__15                 = 16
	CypherParserT__16                 = 17
	CypherParserT__17                 = 18
	CypherParserT__18                 = 19
	CypherParserT__19                 = 20
	CypherParserT__20                 = 21
	CypherParserT__21                 = 22
	CypherParserT__22                 = 23
	CypherParserT__23                 = 24
	CypherParserT__24                 = 25
	CypherParserT__25                 = 26
	CypherParserT__26                 = 27
	CypherParserT__27                 = 28
	CypherParserT__28                 = 29
	CypherParserT__29                 = 30
	CypherParserT__30                 = 31
	CypherParserT__31                 = 32
	CypherParserT__32                 = 33
	CypherParserT__33                 = 34
	CypherParserT__34                 = 35
	CypherParserT__35                 = 36
	CypherParserT__36                 = 37
	CypherParserT__37                 = 38
	CypherParserT__38                 = 39
	CypherParserT__39                 = 40
	CypherParserT__40                 = 41
	CypherParserT__41                 = 42
	CypherParserT__42                 = 43
	CypherParserT__43                 = 44
	CypherParserT__44                 = 45
	CypherParserT__45                 = 46
	CypherParserUNION                 = 47
	CypherParserALL                   = 48
	CypherParserOPTIONAL              = 49
	CypherParserMATCH                 = 50
	CypherParserUNWIND                = 51
	CypherParserAS                    = 52
	CypherParserMERGE                 = 53
	CypherParserON                    = 54
	CypherParserCREATE                = 55
	CypherParserSET                   = 56
	CypherParserDETACH                = 57
	CypherParserDELETE                = 58
	CypherParserREMOVE                = 59
	CypherParserCALL                  = 60
	CypherParserYIELD                 = 61
	CypherParserWITH                  = 62
	CypherParserDISTINCT              = 63
	CypherParserRETURN                = 64
	CypherParserORDER                 = 65
	CypherParserBY                    = 66
	CypherParserL_SKIP                = 67
	CypherParserLIMIT                 = 68
	CypherParserASCENDING             = 69
	CypherParserASC                   = 70
	CypherParserDESCENDING            = 71
	CypherParserDESC                  = 72
	CypherParserWHERE                 = 73
	CypherParserOR                    = 74
	CypherParserXOR                   = 75
	CypherParserAND                   = 76
	CypherParserNOT                   = 77
	CypherParserIN                    = 78
	CypherParserSTARTS                = 79
	CypherParserENDS                  = 80
	CypherParserCONTAINS              = 81
	CypherParserIS                    = 82
	CypherParserNULL                  = 83
	CypherParserCOUNT                 = 84
	CypherParserFILTER                = 85
	CypherParserEXTRACT               = 86
	CypherParserANY                   = 87
	CypherParserNONE                  = 88
	CypherParserSINGLE                = 89
	CypherParserTRUE                  = 90
	CypherParserFALSE                 = 91
	CypherParserEXISTS                = 92
	CypherParserCASE                  = 93
	CypherParserELSE                  = 94
	CypherParserEND                   = 95
	CypherParserWHEN                  = 96
	CypherParserTHEN                  = 97
	CypherParserStringLiteral         = 98
	CypherParserEscapedChar           = 99
	CypherParserHexInteger            = 100
	CypherParserDecimalInteger        = 101
	CypherParserOctalInteger          = 102
	CypherParserHexLetter             = 103
	CypherParserHexDigit              = 104
	CypherParserDigit                 = 105
	CypherParserNonZeroDigit          = 106
	CypherParserNonZeroOctDigit       = 107
	CypherParserOctDigit              = 108
	CypherParserZeroDigit             = 109
	CypherParserExponentDecimalReal   = 110
	CypherParserRegularDecimalReal    = 111
	CypherParserCONSTRAINT            = 112
	CypherParserDO                    = 113
	CypherParserFOR                   = 114
	CypherParserREQUIRE               = 115
	CypherParserUNIQUE                = 116
	CypherParserMANDATORY             = 117
	CypherParserSCALAR                = 118
	CypherParserOF                    = 119
	CypherParserADD                   = 120
	CypherParserDROP                  = 121
	CypherParserUnescapedSymbolicName = 122
	CypherParserIdentifierStart       = 123
	CypherParserIdentifierPart        = 124
	CypherParserEscapedSymbolicName   = 125
	CypherParserSP                    = 126
	CypherParserWHITESPACE            = 127
	CypherParserComment               = 128
)

// CypherParser rules.
const (
	CypherParserRULE_cypher                           = 0
	CypherParserRULE_statement                        = 1
	CypherParserRULE_query                            = 2
	CypherParserRULE_regularQuery                     = 3
	CypherParserRULE_union                            = 4
	CypherParserRULE_singleQuery                      = 5
	CypherParserRULE_singlePartQuery                  = 6
	CypherParserRULE_readOnlyEnd                      = 7
	CypherParserRULE_readUpdateEnd                    = 8
	CypherParserRULE_updatingEnd                      = 9
	CypherParserRULE_multiPartQuery                   = 10
	CypherParserRULE_readPart                         = 11
	CypherParserRULE_updatingPart                     = 12
	CypherParserRULE_updatingStartClause              = 13
	CypherParserRULE_updatingClause                   = 14
	CypherParserRULE_readingClause                    = 15
	CypherParserRULE_match                            = 16
	CypherParserRULE_unwind                           = 17
	CypherParserRULE_merge                            = 18
	CypherParserRULE_mergeAction                      = 19
	CypherParserRULE_create                           = 20
	CypherParserRULE_set                              = 21
	CypherParserRULE_setItem                          = 22
	CypherParserRULE_delete                           = 23
	CypherParserRULE_remove                           = 24
	CypherParserRULE_removeItem                       = 25
	CypherParserRULE_inQueryCall                      = 26
	CypherParserRULE_standaloneCall                   = 27
	CypherParserRULE_yieldItems                       = 28
	CypherParserRULE_yieldItem                        = 29
	CypherParserRULE_with                             = 30
	CypherParserRULE_return                           = 31
	CypherParserRULE_returnBody                       = 32
	CypherParserRULE_returnItems                      = 33
	CypherParserRULE_returnItem                       = 34
	CypherParserRULE_order                            = 35
	CypherParserRULE_skip                             = 36
	CypherParserRULE_limit                            = 37
	CypherParserRULE_sortItem                         = 38
	CypherParserRULE_where                            = 39
	CypherParserRULE_pattern                          = 40
	CypherParserRULE_patternPart                      = 41
	CypherParserRULE_anonymousPatternPart             = 42
	CypherParserRULE_patternElement                   = 43
	CypherParserRULE_nodePattern                      = 44
	CypherParserRULE_patternElementChain              = 45
	CypherParserRULE_relationshipPattern              = 46
	CypherParserRULE_relationshipDetail               = 47
	CypherParserRULE_properties                       = 48
	CypherParserRULE_relationshipTypes                = 49
	CypherParserRULE_nodeLabels                       = 50
	CypherParserRULE_nodeLabel                        = 51
	CypherParserRULE_rangeLiteral                     = 52
	CypherParserRULE_labelName                        = 53
	CypherParserRULE_relTypeName                      = 54
	CypherParserRULE_expression                       = 55
	CypherParserRULE_orExpression                     = 56
	CypherParserRULE_xorExpression                    = 57
	CypherParserRULE_andExpression                    = 58
	CypherParserRULE_notExpression                    = 59
	CypherParserRULE_comparisonExpression             = 60
	CypherParserRULE_addOrSubtractExpression          = 61
	CypherParserRULE_multiplyDivideModuloExpression   = 62
	CypherParserRULE_powerOfExpression                = 63
	CypherParserRULE_unaryAddOrSubtractExpression     = 64
	CypherParserRULE_stringListNullOperatorExpression = 65
	CypherParserRULE_propertyOrLabelsExpression       = 66
	CypherParserRULE_atom                             = 67
	CypherParserRULE_literal                          = 68
	CypherParserRULE_booleanLiteral                   = 69
	CypherParserRULE_listLiteral                      = 70
	CypherParserRULE_partialComparisonExpression      = 71
	CypherParserRULE_parenthesizedExpression          = 72
	CypherParserRULE_relationshipsPattern             = 73
	CypherParserRULE_filterExpression                 = 74
	CypherParserRULE_idInColl                         = 75
	CypherParserRULE_functionInvocation               = 76
	CypherParserRULE_functionName                     = 77
	CypherParserRULE_explicitProcedureInvocation      = 78
	CypherParserRULE_implicitProcedureInvocation      = 79
	CypherParserRULE_procedureResultField             = 80
	CypherParserRULE_procedureName                    = 81
	CypherParserRULE_namespace                        = 82
	CypherParserRULE_listComprehension                = 83
	CypherParserRULE_patternComprehension             = 84
	CypherParserRULE_propertyLookup                   = 85
	CypherParserRULE_caseExpression                   = 86
	CypherParserRULE_caseAlternatives                 = 87
	CypherParserRULE_variable                         = 88
	CypherParserRULE_numberLiteral                    = 89
	CypherParserRULE_mapLiteral                       = 90
	CypherParserRULE_parameter                        = 91
	CypherParserRULE_propertyExpression               = 92
	CypherParserRULE_propertyKeyName                  = 93
	CypherParserRULE_integerLiteral                   = 94
	CypherParserRULE_doubleLiteral                    = 95
	CypherParserRULE_schemaName                       = 96
	CypherParserRULE_reservedWord                     = 97
	CypherParserRULE_symbolicName                     = 98
	CypherParserRULE_leftArrowHead                    = 99
	CypherParserRULE_rightArrowHead                   = 100
	CypherParserRULE_dash                             = 101
)

// ICypherContext is an interface to support dynamic dispatch.
type ICypherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCypherContext differentiates from other interfaces.
	IsCypherContext()
}

type CypherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCypherContext() *CypherContext {
	var p = new(CypherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_cypher
	return p
}

func (*CypherContext) IsCypherContext() {}

func NewCypherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CypherContext {
	var p = new(CypherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_cypher

	return p
}

func (s *CypherContext) GetParser() antlr.Parser { return s.parser }

func (s *CypherContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CypherContext) EOF() antlr.TerminalNode {
	return s.GetToken(CypherParserEOF, 0)
}

func (s *CypherContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CypherContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CypherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CypherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CypherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCypher(s)
	}
}

func (s *CypherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCypher(s)
	}
}

func (p *CypherParser) Cypher() (localctx ICypherContext) {
	localctx = NewCypherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CypherParserRULE_cypher)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(204)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(207)
		p.Statement()
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(208)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(211)
			p.Match(CypherParserT__0)
		}

	}
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(214)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(217)
		p.Match(CypherParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *CypherParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CypherParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Query()
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) RegularQuery() IRegularQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularQueryContext)
}

func (s *QueryContext) StandaloneCall() IStandaloneCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandaloneCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandaloneCallContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *CypherParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CypherParserRULE_query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(221)
			p.RegularQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(222)
			p.StandaloneCall()
		}

	}

	return localctx
}

// IRegularQueryContext is an interface to support dynamic dispatch.
type IRegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularQueryContext differentiates from other interfaces.
	IsRegularQueryContext()
}

type RegularQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularQueryContext() *RegularQueryContext {
	var p = new(RegularQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_regularQuery
	return p
}

func (*RegularQueryContext) IsRegularQueryContext() {}

func NewRegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularQueryContext {
	var p = new(RegularQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_regularQuery

	return p
}

func (s *RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularQueryContext) SingleQuery() ISingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *RegularQueryContext) AllUnion() []IUnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionContext)(nil)).Elem())
	var tst = make([]IUnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionContext)
		}
	}

	return tst
}

func (s *RegularQueryContext) Union(i int) IUnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionContext)
}

func (s *RegularQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RegularQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRegularQuery(s)
	}
}

func (s *RegularQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRegularQuery(s)
	}
}

func (p *CypherParser) RegularQuery() (localctx IRegularQueryContext) {
	localctx = NewRegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CypherParserRULE_regularQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.SingleQuery()
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(227)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(226)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(229)
				p.Union()
			}

		}
		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IUnionContext is an interface to support dynamic dispatch.
type IUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionContext differentiates from other interfaces.
	IsUnionContext()
}

type UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionContext() *UnionContext {
	var p = new(UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_union
	return p
}

func (*UnionContext) IsUnionContext() {}

func NewUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionContext {
	var p = new(UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_union

	return p
}

func (s *UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *UnionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnionContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *UnionContext) SingleQuery() ISingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleQueryContext)
}

func (s *UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnion(s)
	}
}

func (s *UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnion(s)
	}
}

func (p *CypherParser) Union() (localctx IUnionContext) {
	localctx = NewUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CypherParserRULE_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(235)
			p.Match(CypherParserUNION)
		}
		{
			p.SetState(236)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(237)
			p.Match(CypherParserALL)
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(238)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(241)
			p.SingleQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(242)
			p.Match(CypherParserUNION)
		}
		p.SetState(244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(243)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(246)
			p.SingleQuery()
		}

	}

	return localctx
}

// ISingleQueryContext is an interface to support dynamic dispatch.
type ISingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleQueryContext differentiates from other interfaces.
	IsSingleQueryContext()
}

type SingleQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQueryContext() *SingleQueryContext {
	var p = new(SingleQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singleQuery
	return p
}

func (*SingleQueryContext) IsSingleQueryContext() {}

func NewSingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQueryContext {
	var p = new(SingleQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singleQuery

	return p
}

func (s *SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQueryContext) SinglePartQuery() ISinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISinglePartQueryContext)
}

func (s *SingleQueryContext) MultiPartQuery() IMultiPartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiPartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiPartQueryContext)
}

func (s *SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSingleQuery(s)
	}
}

func (s *SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSingleQuery(s)
	}
}

func (p *CypherParser) SingleQuery() (localctx ISingleQueryContext) {
	localctx = NewSingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CypherParserRULE_singleQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.SinglePartQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(250)
			p.MultiPartQuery()
		}

	}

	return localctx
}

// ISinglePartQueryContext is an interface to support dynamic dispatch.
type ISinglePartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSinglePartQueryContext differentiates from other interfaces.
	IsSinglePartQueryContext()
}

type SinglePartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinglePartQueryContext() *SinglePartQueryContext {
	var p = new(SinglePartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_singlePartQuery
	return p
}

func (*SinglePartQueryContext) IsSinglePartQueryContext() {}

func NewSinglePartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinglePartQueryContext {
	var p = new(SinglePartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_singlePartQuery

	return p
}

func (s *SinglePartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SinglePartQueryContext) ReadOnlyEnd() IReadOnlyEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadOnlyEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadOnlyEndContext)
}

func (s *SinglePartQueryContext) ReadUpdateEnd() IReadUpdateEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadUpdateEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadUpdateEndContext)
}

func (s *SinglePartQueryContext) UpdatingEnd() IUpdatingEndContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingEndContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdatingEndContext)
}

func (s *SinglePartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinglePartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinglePartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSinglePartQuery(s)
	}
}

func (s *SinglePartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSinglePartQuery(s)
	}
}

func (p *CypherParser) SinglePartQuery() (localctx ISinglePartQueryContext) {
	localctx = NewSinglePartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CypherParserRULE_singlePartQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.ReadOnlyEnd()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(254)
			p.ReadUpdateEnd()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(255)
			p.UpdatingEnd()
		}

	}

	return localctx
}

// IReadOnlyEndContext is an interface to support dynamic dispatch.
type IReadOnlyEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadOnlyEndContext differentiates from other interfaces.
	IsReadOnlyEndContext()
}

type ReadOnlyEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadOnlyEndContext() *ReadOnlyEndContext {
	var p = new(ReadOnlyEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_readOnlyEnd
	return p
}

func (*ReadOnlyEndContext) IsReadOnlyEndContext() {}

func NewReadOnlyEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadOnlyEndContext {
	var p = new(ReadOnlyEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readOnlyEnd

	return p
}

func (s *ReadOnlyEndContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadOnlyEndContext) ReadPart() IReadPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadPartContext)
}

func (s *ReadOnlyEndContext) Return() IReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnContext)
}

func (s *ReadOnlyEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadOnlyEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadOnlyEndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReadOnlyEnd(s)
	}
}

func (s *ReadOnlyEndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReadOnlyEnd(s)
	}
}

func (p *CypherParser) ReadOnlyEnd() (localctx IReadOnlyEndContext) {
	localctx = NewReadOnlyEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CypherParserRULE_readOnlyEnd)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(258)
		p.ReadPart()
	}
	{
		p.SetState(259)
		p.Return()
	}

	return localctx
}

// IReadUpdateEndContext is an interface to support dynamic dispatch.
type IReadUpdateEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadUpdateEndContext differentiates from other interfaces.
	IsReadUpdateEndContext()
}

type ReadUpdateEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadUpdateEndContext() *ReadUpdateEndContext {
	var p = new(ReadUpdateEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_readUpdateEnd
	return p
}

func (*ReadUpdateEndContext) IsReadUpdateEndContext() {}

func NewReadUpdateEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadUpdateEndContext {
	var p = new(ReadUpdateEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readUpdateEnd

	return p
}

func (s *ReadUpdateEndContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadUpdateEndContext) AllReadingClause() []IReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem())
	var tst = make([]IReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReadingClauseContext)
		}
	}

	return tst
}

func (s *ReadUpdateEndContext) ReadingClause(i int) IReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReadingClauseContext)
}

func (s *ReadUpdateEndContext) AllUpdatingClause() []IUpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem())
	var tst = make([]IUpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingClauseContext)
		}
	}

	return tst
}

func (s *ReadUpdateEndContext) UpdatingClause(i int) IUpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingClauseContext)
}

func (s *ReadUpdateEndContext) Return() IReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnContext)
}

func (s *ReadUpdateEndContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReadUpdateEndContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReadUpdateEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUpdateEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadUpdateEndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReadUpdateEnd(s)
	}
}

func (s *ReadUpdateEndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReadUpdateEnd(s)
	}
}

func (p *CypherParser) ReadUpdateEnd() (localctx IReadUpdateEndContext) {
	localctx = NewReadUpdateEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CypherParserRULE_readUpdateEnd)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.ReadingClause()
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(262)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(265)
				p.ReadingClause()
			}

		}
		p.SetState(270)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(272)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(271)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(274)
				p.UpdatingClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
	}
	p.SetState(283)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(279)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(282)
			p.Return()
		}

	}

	return localctx
}

// IUpdatingEndContext is an interface to support dynamic dispatch.
type IUpdatingEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdatingEndContext differentiates from other interfaces.
	IsUpdatingEndContext()
}

type UpdatingEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingEndContext() *UpdatingEndContext {
	var p = new(UpdatingEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_updatingEnd
	return p
}

func (*UpdatingEndContext) IsUpdatingEndContext() {}

func NewUpdatingEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingEndContext {
	var p = new(UpdatingEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingEnd

	return p
}

func (s *UpdatingEndContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingEndContext) UpdatingStartClause() IUpdatingStartClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingStartClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdatingStartClauseContext)
}

func (s *UpdatingEndContext) AllUpdatingClause() []IUpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem())
	var tst = make([]IUpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingClauseContext)
		}
	}

	return tst
}

func (s *UpdatingEndContext) UpdatingClause(i int) IUpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingClauseContext)
}

func (s *UpdatingEndContext) Return() IReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnContext)
}

func (s *UpdatingEndContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UpdatingEndContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UpdatingEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingEndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUpdatingEnd(s)
	}
}

func (s *UpdatingEndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUpdatingEnd(s)
	}
}

func (p *CypherParser) UpdatingEnd() (localctx IUpdatingEndContext) {
	localctx = NewUpdatingEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CypherParserRULE_updatingEnd)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.UpdatingStartClause()
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(287)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(286)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(289)
				p.UpdatingClause()
			}

		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(295)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(298)
			p.Return()
		}

	}

	return localctx
}

// IMultiPartQueryContext is an interface to support dynamic dispatch.
type IMultiPartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiPartQueryContext differentiates from other interfaces.
	IsMultiPartQueryContext()
}

type MultiPartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiPartQueryContext() *MultiPartQueryContext {
	var p = new(MultiPartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiPartQuery
	return p
}

func (*MultiPartQueryContext) IsMultiPartQueryContext() {}

func NewMultiPartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiPartQueryContext {
	var p = new(MultiPartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiPartQuery

	return p
}

func (s *MultiPartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiPartQueryContext) AllWith() []IWithContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWithContext)(nil)).Elem())
	var tst = make([]IWithContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWithContext)
		}
	}

	return tst
}

func (s *MultiPartQueryContext) With(i int) IWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *MultiPartQueryContext) SinglePartQuery() ISinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISinglePartQueryContext)
}

func (s *MultiPartQueryContext) AllReadPart() []IReadPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReadPartContext)(nil)).Elem())
	var tst = make([]IReadPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReadPartContext)
		}
	}

	return tst
}

func (s *MultiPartQueryContext) ReadPart(i int) IReadPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReadPartContext)
}

func (s *MultiPartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MultiPartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MultiPartQueryContext) AllUpdatingPart() []IUpdatingPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingPartContext)(nil)).Elem())
	var tst = make([]IUpdatingPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingPartContext)
		}
	}

	return tst
}

func (s *MultiPartQueryContext) UpdatingPart(i int) IUpdatingPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingPartContext)
}

func (s *MultiPartQueryContext) UpdatingStartClause() IUpdatingStartClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingStartClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdatingStartClauseContext)
}

func (s *MultiPartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiPartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiPartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMultiPartQuery(s)
	}
}

func (s *MultiPartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMultiPartQuery(s)
	}
}

func (p *CypherParser) MultiPartQuery() (localctx IMultiPartQueryContext) {
	localctx = NewMultiPartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CypherParserRULE_multiPartQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(308)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserCALL, CypherParserWITH:
		{
			p.SetState(301)
			p.ReadPart()
		}

	case CypherParserMERGE, CypherParserCREATE:
		{
			p.SetState(302)
			p.UpdatingStartClause()
		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(303)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(306)
			p.UpdatingPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(310)
		p.With()
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(311)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(314)
				p.ReadPart()
			}
			{
				p.SetState(315)
				p.UpdatingPart()
			}
			{
				p.SetState(316)
				p.With()
			}
			p.SetState(318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(317)
					p.Match(CypherParserSP)
				}

			}

		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}
	{
		p.SetState(325)
		p.SinglePartQuery()
	}

	return localctx
}

// IReadPartContext is an interface to support dynamic dispatch.
type IReadPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadPartContext differentiates from other interfaces.
	IsReadPartContext()
}

type ReadPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadPartContext() *ReadPartContext {
	var p = new(ReadPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_readPart
	return p
}

func (*ReadPartContext) IsReadPartContext() {}

func NewReadPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadPartContext {
	var p = new(ReadPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readPart

	return p
}

func (s *ReadPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadPartContext) AllReadingClause() []IReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem())
	var tst = make([]IReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReadingClauseContext)
		}
	}

	return tst
}

func (s *ReadPartContext) ReadingClause(i int) IReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReadingClauseContext)
}

func (s *ReadPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReadPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReadPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReadPart(s)
	}
}

func (s *ReadPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReadPart(s)
	}
}

func (p *CypherParser) ReadPart() (localctx IReadPartContext) {
	localctx = NewReadPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CypherParserRULE_readPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(CypherParserOPTIONAL-49))|(1<<(CypherParserMATCH-49))|(1<<(CypherParserUNWIND-49))|(1<<(CypherParserCALL-49)))) != 0 {
		{
			p.SetState(327)
			p.ReadingClause()
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(328)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUpdatingPartContext is an interface to support dynamic dispatch.
type IUpdatingPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdatingPartContext differentiates from other interfaces.
	IsUpdatingPartContext()
}

type UpdatingPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingPartContext() *UpdatingPartContext {
	var p = new(UpdatingPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_updatingPart
	return p
}

func (*UpdatingPartContext) IsUpdatingPartContext() {}

func NewUpdatingPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingPartContext {
	var p = new(UpdatingPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingPart

	return p
}

func (s *UpdatingPartContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingPartContext) AllUpdatingClause() []IUpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem())
	var tst = make([]IUpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdatingClauseContext)
		}
	}

	return tst
}

func (s *UpdatingPartContext) UpdatingClause(i int) IUpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdatingClauseContext)
}

func (s *UpdatingPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UpdatingPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UpdatingPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUpdatingPart(s)
	}
}

func (s *UpdatingPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUpdatingPart(s)
	}
}

func (p *CypherParser) UpdatingPart() (localctx IUpdatingPartContext) {
	localctx = NewUpdatingPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CypherParserRULE_updatingPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(CypherParserMERGE-53))|(1<<(CypherParserCREATE-53))|(1<<(CypherParserSET-53))|(1<<(CypherParserDETACH-53))|(1<<(CypherParserDELETE-53))|(1<<(CypherParserREMOVE-53)))) != 0 {
		{
			p.SetState(336)
			p.UpdatingClause()
		}
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(337)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUpdatingStartClauseContext is an interface to support dynamic dispatch.
type IUpdatingStartClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdatingStartClauseContext differentiates from other interfaces.
	IsUpdatingStartClauseContext()
}

type UpdatingStartClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingStartClauseContext() *UpdatingStartClauseContext {
	var p = new(UpdatingStartClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_updatingStartClause
	return p
}

func (*UpdatingStartClauseContext) IsUpdatingStartClauseContext() {}

func NewUpdatingStartClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingStartClauseContext {
	var p = new(UpdatingStartClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingStartClause

	return p
}

func (s *UpdatingStartClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingStartClauseContext) Create() ICreateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateContext)
}

func (s *UpdatingStartClauseContext) Merge() IMergeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeContext)
}

func (s *UpdatingStartClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingStartClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingStartClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUpdatingStartClause(s)
	}
}

func (s *UpdatingStartClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUpdatingStartClause(s)
	}
}

func (p *CypherParser) UpdatingStartClause() (localctx IUpdatingStartClauseContext) {
	localctx = NewUpdatingStartClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CypherParserRULE_updatingStartClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(345)
			p.Create()
		}

	case CypherParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(346)
			p.Merge()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUpdatingClauseContext is an interface to support dynamic dispatch.
type IUpdatingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdatingClauseContext differentiates from other interfaces.
	IsUpdatingClauseContext()
}

type UpdatingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatingClauseContext() *UpdatingClauseContext {
	var p = new(UpdatingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_updatingClause
	return p
}

func (*UpdatingClauseContext) IsUpdatingClauseContext() {}

func NewUpdatingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatingClauseContext {
	var p = new(UpdatingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_updatingClause

	return p
}

func (s *UpdatingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatingClauseContext) Create() ICreateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateContext)
}

func (s *UpdatingClauseContext) Merge() IMergeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeContext)
}

func (s *UpdatingClauseContext) Delete() IDeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteContext)
}

func (s *UpdatingClauseContext) Set() ISetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetContext)
}

func (s *UpdatingClauseContext) Remove() IRemoveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemoveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemoveContext)
}

func (s *UpdatingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUpdatingClause(s)
	}
}

func (s *UpdatingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUpdatingClause(s)
	}
}

func (p *CypherParser) UpdatingClause() (localctx IUpdatingClauseContext) {
	localctx = NewUpdatingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CypherParserRULE_updatingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(354)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(349)
			p.Create()
		}

	case CypherParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(350)
			p.Merge()
		}

	case CypherParserDETACH, CypherParserDELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(351)
			p.Delete()
		}

	case CypherParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(352)
			p.Set()
		}

	case CypherParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(353)
			p.Remove()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadingClauseContext is an interface to support dynamic dispatch.
type IReadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadingClauseContext differentiates from other interfaces.
	IsReadingClauseContext()
}

type ReadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadingClauseContext() *ReadingClauseContext {
	var p = new(ReadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_readingClause
	return p
}

func (*ReadingClauseContext) IsReadingClauseContext() {}

func NewReadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadingClauseContext {
	var p = new(ReadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_readingClause

	return p
}

func (s *ReadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadingClauseContext) Match() IMatchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatchContext)
}

func (s *ReadingClauseContext) Unwind() IUnwindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnwindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnwindContext)
}

func (s *ReadingClauseContext) InQueryCall() IInQueryCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInQueryCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInQueryCallContext)
}

func (s *ReadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReadingClause(s)
	}
}

func (s *ReadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReadingClause(s)
	}
}

func (p *CypherParser) ReadingClause() (localctx IReadingClauseContext) {
	localctx = NewReadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CypherParserRULE_readingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(359)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserOPTIONAL, CypherParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(356)
			p.Match()
		}

	case CypherParserUNWIND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(357)
			p.Unwind()
		}

	case CypherParserCALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(358)
			p.InQueryCall()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatchContext is an interface to support dynamic dispatch.
type IMatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchContext differentiates from other interfaces.
	IsMatchContext()
}

type MatchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchContext() *MatchContext {
	var p = new(MatchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_match
	return p
}

func (*MatchContext) IsMatchContext() {}

func NewMatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchContext {
	var p = new(MatchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_match

	return p
}

func (s *MatchContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MatchContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *MatchContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MatchContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MatchContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *MatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMatch(s)
	}
}

func (s *MatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMatch(s)
	}
}

func (p *CypherParser) Match() (localctx IMatchContext) {
	localctx = NewMatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CypherParserRULE_match)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserOPTIONAL {
		{
			p.SetState(361)
			p.Match(CypherParserOPTIONAL)
		}
		{
			p.SetState(362)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(365)
		p.Match(CypherParserMATCH)
	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(366)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(369)
		p.Pattern()
	}
	p.SetState(374)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(370)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(373)
			p.Where()
		}

	}

	return localctx
}

// IUnwindContext is an interface to support dynamic dispatch.
type IUnwindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnwindContext differentiates from other interfaces.
	IsUnwindContext()
}

type UnwindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnwindContext() *UnwindContext {
	var p = new(UnwindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unwind
	return p
}

func (*UnwindContext) IsUnwindContext() {}

func NewUnwindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnwindContext {
	var p = new(UnwindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unwind

	return p
}

func (s *UnwindContext) GetParser() antlr.Parser { return s.parser }

func (s *UnwindContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *UnwindContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnwindContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnwindContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnwindContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *UnwindContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *UnwindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnwindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnwindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnwind(s)
	}
}

func (s *UnwindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnwind(s)
	}
}

func (p *CypherParser) Unwind() (localctx IUnwindContext) {
	localctx = NewUnwindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CypherParserRULE_unwind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(CypherParserUNWIND)
	}
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(377)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(380)
		p.Expression()
	}
	{
		p.SetState(381)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(382)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(383)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(384)
		p.Variable()
	}

	return localctx
}

// IMergeContext is an interface to support dynamic dispatch.
type IMergeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeContext differentiates from other interfaces.
	IsMergeContext()
}

type MergeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeContext() *MergeContext {
	var p = new(MergeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_merge
	return p
}

func (*MergeContext) IsMergeContext() {}

func NewMergeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeContext {
	var p = new(MergeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_merge

	return p
}

func (s *MergeContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *MergeContext) PatternPart() IPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *MergeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeContext) AllMergeAction() []IMergeActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeActionContext)(nil)).Elem())
	var tst = make([]IMergeActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeActionContext)
		}
	}

	return tst
}

func (s *MergeContext) MergeAction(i int) IMergeActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeActionContext)
}

func (s *MergeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMerge(s)
	}
}

func (s *MergeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMerge(s)
	}
}

func (p *CypherParser) Merge() (localctx IMergeContext) {
	localctx = NewMergeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CypherParserRULE_merge)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(CypherParserMERGE)
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(387)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(390)
		p.PatternPart()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(391)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(392)
				p.MergeAction()
			}

		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IMergeActionContext is an interface to support dynamic dispatch.
type IMergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeActionContext differentiates from other interfaces.
	IsMergeActionContext()
}

type MergeActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeActionContext() *MergeActionContext {
	var p = new(MergeActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mergeAction
	return p
}

func (*MergeActionContext) IsMergeActionContext() {}

func NewMergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeActionContext {
	var p = new(MergeActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mergeAction

	return p
}

func (s *MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *MergeActionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MergeActionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *MergeActionContext) Set() ISetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetContext)
}

func (s *MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMergeAction(s)
	}
}

func (s *MergeActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMergeAction(s)
	}
}

func (p *CypherParser) MergeAction() (localctx IMergeActionContext) {
	localctx = NewMergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CypherParserRULE_mergeAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(398)
			p.Match(CypherParserON)
		}
		{
			p.SetState(399)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(400)
			p.Match(CypherParserMATCH)
		}
		{
			p.SetState(401)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(402)
			p.Set()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(403)
			p.Match(CypherParserON)
		}
		{
			p.SetState(404)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(405)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(406)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(407)
			p.Set()
		}

	}

	return localctx
}

// ICreateContext is an interface to support dynamic dispatch.
type ICreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateContext differentiates from other interfaces.
	IsCreateContext()
}

type CreateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateContext() *CreateContext {
	var p = new(CreateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_create
	return p
}

func (*CreateContext) IsCreateContext() {}

func NewCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateContext {
	var p = new(CreateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_create

	return p
}

func (s *CreateContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *CreateContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CreateContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *CreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCreate(s)
	}
}

func (s *CreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCreate(s)
	}
}

func (p *CypherParser) Create() (localctx ICreateContext) {
	localctx = NewCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CypherParserRULE_create)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(CypherParserCREATE)
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(411)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(414)
		p.Pattern()
	}

	return localctx
}

// ISetContext is an interface to support dynamic dispatch.
type ISetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetContext differentiates from other interfaces.
	IsSetContext()
}

type SetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetContext() *SetContext {
	var p = new(SetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_set
	return p
}

func (*SetContext) IsSetContext() {}

func NewSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetContext {
	var p = new(SetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_set

	return p
}

func (s *SetContext) GetParser() antlr.Parser { return s.parser }

func (s *SetContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *SetContext) AllSetItem() []ISetItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetItemContext)(nil)).Elem())
	var tst = make([]ISetItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetItemContext)
		}
	}

	return tst
}

func (s *SetContext) SetItem(i int) ISetItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetItemContext)
}

func (s *SetContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSet(s)
	}
}

func (s *SetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSet(s)
	}
}

func (p *CypherParser) Set() (localctx ISetContext) {
	localctx = NewSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CypherParserRULE_set)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(CypherParserSET)
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(417)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(420)
		p.SetItem()
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__1 {
		{
			p.SetState(421)
			p.Match(CypherParserT__1)
		}
		{
			p.SetState(422)
			p.SetItem()
		}

		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISetItemContext is an interface to support dynamic dispatch.
type ISetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetItemContext differentiates from other interfaces.
	IsSetItemContext()
}

type SetItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemContext() *SetItemContext {
	var p = new(SetItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_setItem
	return p
}

func (*SetItemContext) IsSetItemContext() {}

func NewSetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemContext {
	var p = new(SetItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_setItem

	return p
}

func (s *SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemContext) PropertyExpression() IPropertyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *SetItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *SetItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *SetItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetItemContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSetItem(s)
	}
}

func (s *SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSetItem(s)
	}
}

func (p *CypherParser) SetItem() (localctx ISetItemContext) {
	localctx = NewSetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CypherParserRULE_setItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(428)
			p.PropertyExpression()
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(429)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(432)
			p.Match(CypherParserT__2)
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(433)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(436)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(438)
			p.Variable()
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(439)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(442)
			p.Match(CypherParserT__2)
		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(443)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(446)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.Variable()
		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(449)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(452)
			p.Match(CypherParserT__3)
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(453)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(456)
			p.Expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(458)
			p.Variable()
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(459)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(462)
			p.NodeLabels()
		}

	}

	return localctx
}

// IDeleteContext is an interface to support dynamic dispatch.
type IDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteContext differentiates from other interfaces.
	IsDeleteContext()
}

type DeleteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteContext() *DeleteContext {
	var p = new(DeleteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_delete
	return p
}

func (*DeleteContext) IsDeleteContext() {}

func NewDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteContext {
	var p = new(DeleteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_delete

	return p
}

func (s *DeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *DeleteContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *DeleteContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *DeleteContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *DeleteContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDelete(s)
	}
}

func (p *CypherParser) Delete() (localctx IDeleteContext) {
	localctx = NewDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CypherParserRULE_delete)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDETACH {
		{
			p.SetState(466)
			p.Match(CypherParserDETACH)
		}
		{
			p.SetState(467)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(470)
		p.Match(CypherParserDELETE)
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(471)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(474)
		p.Expression()
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(475)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(478)
				p.Match(CypherParserT__1)
			}
			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(479)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(482)
				p.Expression()
			}

		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveContext is an interface to support dynamic dispatch.
type IRemoveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveContext differentiates from other interfaces.
	IsRemoveContext()
}

type RemoveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveContext() *RemoveContext {
	var p = new(RemoveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_remove
	return p
}

func (*RemoveContext) IsRemoveContext() {}

func NewRemoveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveContext {
	var p = new(RemoveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_remove

	return p
}

func (s *RemoveContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *RemoveContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RemoveContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RemoveContext) AllRemoveItem() []IRemoveItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRemoveItemContext)(nil)).Elem())
	var tst = make([]IRemoveItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRemoveItemContext)
		}
	}

	return tst
}

func (s *RemoveContext) RemoveItem(i int) IRemoveItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemoveItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRemoveItemContext)
}

func (s *RemoveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRemove(s)
	}
}

func (s *RemoveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRemove(s)
	}
}

func (p *CypherParser) Remove() (localctx IRemoveContext) {
	localctx = NewRemoveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CypherParserRULE_remove)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Match(CypherParserREMOVE)
	}
	{
		p.SetState(489)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(490)
		p.RemoveItem()
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(492)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(491)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(494)
				p.Match(CypherParserT__1)
			}
			p.SetState(496)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(495)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(498)
				p.RemoveItem()
			}

		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
	}

	return localctx
}

// IRemoveItemContext is an interface to support dynamic dispatch.
type IRemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveItemContext differentiates from other interfaces.
	IsRemoveItemContext()
}

type RemoveItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemContext() *RemoveItemContext {
	var p = new(RemoveItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_removeItem
	return p
}

func (*RemoveItemContext) IsRemoveItemContext() {}

func NewRemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemContext {
	var p = new(RemoveItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_removeItem

	return p
}

func (s *RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RemoveItemContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *RemoveItemContext) PropertyExpression() IPropertyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyExpressionContext)
}

func (s *RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRemoveItem(s)
	}
}

func (s *RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRemoveItem(s)
	}
}

func (p *CypherParser) RemoveItem() (localctx IRemoveItemContext) {
	localctx = NewRemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CypherParserRULE_removeItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(504)
			p.Variable()
		}
		{
			p.SetState(505)
			p.NodeLabels()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.PropertyExpression()
		}

	}

	return localctx
}

// IInQueryCallContext is an interface to support dynamic dispatch.
type IInQueryCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInQueryCallContext differentiates from other interfaces.
	IsInQueryCallContext()
}

type InQueryCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInQueryCallContext() *InQueryCallContext {
	var p = new(InQueryCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_inQueryCall
	return p
}

func (*InQueryCallContext) IsInQueryCallContext() {}

func NewInQueryCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InQueryCallContext {
	var p = new(InQueryCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_inQueryCall

	return p
}

func (s *InQueryCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InQueryCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *InQueryCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *InQueryCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *InQueryCallContext) ExplicitProcedureInvocation() IExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitProcedureInvocationContext)
}

func (s *InQueryCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *InQueryCallContext) YieldItems() IYieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *InQueryCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InQueryCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InQueryCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterInQueryCall(s)
	}
}

func (s *InQueryCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitInQueryCall(s)
	}
}

func (p *CypherParser) InQueryCall() (localctx IInQueryCallContext) {
	localctx = NewInQueryCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CypherParserRULE_inQueryCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(511)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(512)
		p.ExplicitProcedureInvocation()
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(513)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(516)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(517)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(518)
			p.YieldItems()
		}

	}

	return localctx
}

// IStandaloneCallContext is an interface to support dynamic dispatch.
type IStandaloneCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneCallContext differentiates from other interfaces.
	IsStandaloneCallContext()
}

type StandaloneCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneCallContext() *StandaloneCallContext {
	var p = new(StandaloneCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_standaloneCall
	return p
}

func (*StandaloneCallContext) IsStandaloneCallContext() {}

func NewStandaloneCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneCallContext {
	var p = new(StandaloneCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_standaloneCall

	return p
}

func (s *StandaloneCallContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *StandaloneCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StandaloneCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StandaloneCallContext) ExplicitProcedureInvocation() IExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitProcedureInvocationContext)
}

func (s *StandaloneCallContext) ImplicitProcedureInvocation() IImplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitProcedureInvocationContext)
}

func (s *StandaloneCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *StandaloneCallContext) YieldItems() IYieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldItemsContext)
}

func (s *StandaloneCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStandaloneCall(s)
	}
}

func (s *StandaloneCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStandaloneCall(s)
	}
}

func (p *CypherParser) StandaloneCall() (localctx IStandaloneCallContext) {
	localctx = NewStandaloneCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CypherParserRULE_standaloneCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(522)
		p.Match(CypherParserSP)
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(523)
			p.ExplicitProcedureInvocation()
		}

	case 2:
		{
			p.SetState(524)
			p.ImplicitProcedureInvocation()
		}

	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(527)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(528)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(529)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(530)
			p.YieldItems()
		}

	}

	return localctx
}

// IYieldItemsContext is an interface to support dynamic dispatch.
type IYieldItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldItemsContext differentiates from other interfaces.
	IsYieldItemsContext()
}

type YieldItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemsContext() *YieldItemsContext {
	var p = new(YieldItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItems
	return p
}

func (*YieldItemsContext) IsYieldItemsContext() {}

func NewYieldItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemsContext {
	var p = new(YieldItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItems

	return p
}

func (s *YieldItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemsContext) AllYieldItem() []IYieldItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYieldItemContext)(nil)).Elem())
	var tst = make([]IYieldItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYieldItemContext)
		}
	}

	return tst
}

func (s *YieldItemsContext) YieldItem(i int) IYieldItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYieldItemContext)
}

func (s *YieldItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *YieldItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *YieldItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterYieldItems(s)
	}
}

func (s *YieldItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitYieldItems(s)
	}
}

func (p *CypherParser) YieldItems() (localctx IYieldItemsContext) {
	localctx = NewYieldItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CypherParserRULE_yieldItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(548)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserALL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)
			p.YieldItem()
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(535)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(534)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(537)
					p.Match(CypherParserT__1)
				}
				p.SetState(539)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(538)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(541)
					p.YieldItem()
				}

			}
			p.SetState(546)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
		}

	case CypherParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(547)
			p.Match(CypherParserT__4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IYieldItemContext is an interface to support dynamic dispatch.
type IYieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldItemContext differentiates from other interfaces.
	IsYieldItemContext()
}

type YieldItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemContext() *YieldItemContext {
	var p = new(YieldItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_yieldItem
	return p
}

func (*YieldItemContext) IsYieldItemContext() {}

func NewYieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemContext {
	var p = new(YieldItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_yieldItem

	return p
}

func (s *YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *YieldItemContext) ProcedureResultField() IProcedureResultFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureResultFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureResultFieldContext)
}

func (s *YieldItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *YieldItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *YieldItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterYieldItem(s)
	}
}

func (s *YieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitYieldItem(s)
	}
}

func (p *CypherParser) YieldItem() (localctx IYieldItemContext) {
	localctx = NewYieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CypherParserRULE_yieldItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			p.ProcedureResultField()
		}
		{
			p.SetState(551)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(552)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(553)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(557)
		p.Variable()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *WithContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *WithContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *WithContext) ReturnBody() IReturnBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *WithContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *WithContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitWith(s)
	}
}

func (p *CypherParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CypherParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(CypherParserWITH)
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(560)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(563)
			p.Match(CypherParserDISTINCT)
		}

	}
	{
		p.SetState(566)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(567)
		p.ReturnBody()
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(568)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(571)
			p.Where()
		}

	}

	return localctx
}

// IReturnContext is an interface to support dynamic dispatch.
type IReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnContext differentiates from other interfaces.
	IsReturnContext()
}

type ReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnContext() *ReturnContext {
	var p = new(ReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_return
	return p
}

func (*ReturnContext) IsReturnContext() {}

func NewReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnContext {
	var p = new(ReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_return

	return p
}

func (s *ReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReturnContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnContext) ReturnBody() IReturnBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnBodyContext)
}

func (s *ReturnContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturn(s)
	}
}

func (s *ReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturn(s)
	}
}

func (p *CypherParser) Return() (localctx IReturnContext) {
	localctx = NewReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CypherParserRULE_return)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(CypherParserRETURN)
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(575)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(578)
			p.Match(CypherParserDISTINCT)
		}

	}
	{
		p.SetState(581)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(582)
		p.ReturnBody()
	}

	return localctx
}

// IReturnBodyContext is an interface to support dynamic dispatch.
type IReturnBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnBodyContext differentiates from other interfaces.
	IsReturnBodyContext()
}

type ReturnBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnBodyContext() *ReturnBodyContext {
	var p = new(ReturnBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnBody
	return p
}

func (*ReturnBodyContext) IsReturnBodyContext() {}

func NewReturnBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnBodyContext {
	var p = new(ReturnBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnBody

	return p
}

func (s *ReturnBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnBodyContext) ReturnItems() IReturnItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnItemsContext)
}

func (s *ReturnBodyContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnBodyContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnBodyContext) Order() IOrderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderContext)
}

func (s *ReturnBodyContext) Skip() ISkipContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISkipContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISkipContext)
}

func (s *ReturnBodyContext) Limit() ILimitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitContext)
}

func (s *ReturnBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnBody(s)
	}
}

func (s *ReturnBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnBody(s)
	}
}

func (p *CypherParser) ReturnBody() (localctx IReturnBodyContext) {
	localctx = NewReturnBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CypherParserRULE_returnBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.ReturnItems()
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(585)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(586)
			p.Order()
		}

	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(589)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(590)
			p.Skip()
		}

	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(593)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(594)
			p.Limit()
		}

	}

	return localctx
}

// IReturnItemsContext is an interface to support dynamic dispatch.
type IReturnItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemsContext differentiates from other interfaces.
	IsReturnItemsContext()
}

type ReturnItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemsContext() *ReturnItemsContext {
	var p = new(ReturnItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItems
	return p
}

func (*ReturnItemsContext) IsReturnItemsContext() {}

func NewReturnItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemsContext {
	var p = new(ReturnItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItems

	return p
}

func (s *ReturnItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemsContext) AllReturnItem() []IReturnItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReturnItemContext)(nil)).Elem())
	var tst = make([]IReturnItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReturnItemContext)
		}
	}

	return tst
}

func (s *ReturnItemsContext) ReturnItem(i int) IReturnItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReturnItemContext)
}

func (s *ReturnItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnItems(s)
	}
}

func (s *ReturnItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnItems(s)
	}
}

func (p *CypherParser) ReturnItems() (localctx IReturnItemsContext) {
	localctx = NewReturnItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CypherParserRULE_returnItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(625)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(597)
			p.Match(CypherParserT__5)
		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(599)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(598)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(601)
					p.Match(CypherParserT__1)
				}
				p.SetState(603)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(602)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(605)
					p.ReturnItem()
				}

			}
			p.SetState(610)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
		}

	case CypherParserT__4, CypherParserT__6, CypherParserT__8, CypherParserT__13, CypherParserT__24, CypherParserT__26, CypherParserALL, CypherParserNOT, CypherParserNULL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserTRUE, CypherParserFALSE, CypherParserEXISTS, CypherParserCASE, CypherParserStringLiteral, CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserHexLetter, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.ReturnItem()
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(613)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(612)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(615)
					p.Match(CypherParserT__1)
				}
				p.SetState(617)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(616)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(619)
					p.ReturnItem()
				}

			}
			p.SetState(624)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnItemContext is an interface to support dynamic dispatch.
type IReturnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnItemContext differentiates from other interfaces.
	IsReturnItemContext()
}

type ReturnItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemContext() *ReturnItemContext {
	var p = new(ReturnItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_returnItem
	return p
}

func (*ReturnItemContext) IsReturnItemContext() {}

func NewReturnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemContext {
	var p = new(ReturnItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_returnItem

	return p
}

func (s *ReturnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ReturnItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ReturnItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReturnItemContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ReturnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReturnItem(s)
	}
}

func (s *ReturnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReturnItem(s)
	}
}

func (p *CypherParser) ReturnItem() (localctx IReturnItemContext) {
	localctx = NewReturnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CypherParserRULE_returnItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.Expression()
		}
		{
			p.SetState(628)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(629)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(630)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(631)
			p.Variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(633)
			p.Expression()
		}

	}

	return localctx
}

// IOrderContext is an interface to support dynamic dispatch.
type IOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderContext differentiates from other interfaces.
	IsOrderContext()
}

type OrderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderContext() *OrderContext {
	var p = new(OrderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_order
	return p
}

func (*OrderContext) IsOrderContext() {}

func NewOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderContext {
	var p = new(OrderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_order

	return p
}

func (s *OrderContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OrderContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrderContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrderContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OrderContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OrderContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOrder(s)
	}
}

func (s *OrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOrder(s)
	}
}

func (p *CypherParser) Order() (localctx IOrderContext) {
	localctx = NewOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CypherParserRULE_order)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(CypherParserORDER)
	}
	{
		p.SetState(637)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(638)
		p.Match(CypherParserBY)
	}
	{
		p.SetState(639)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(640)
		p.SortItem()
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__1 {
		{
			p.SetState(641)
			p.Match(CypherParserT__1)
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(642)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(645)
			p.SortItem()
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISkipContext is an interface to support dynamic dispatch.
type ISkipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSkipContext differentiates from other interfaces.
	IsSkipContext()
}

type SkipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipContext() *SkipContext {
	var p = new(SkipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_skip
	return p
}

func (*SkipContext) IsSkipContext() {}

func NewSkipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipContext {
	var p = new(SkipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_skip

	return p
}

func (s *SkipContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *SkipContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SkipContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SkipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSkip(s)
	}
}

func (s *SkipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSkip(s)
	}
}

func (p *CypherParser) Skip() (localctx ISkipContext) {
	localctx = NewSkipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CypherParserRULE_skip)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(CypherParserL_SKIP)
	}
	{
		p.SetState(652)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(653)
		p.Expression()
	}

	return localctx
}

// ILimitContext is an interface to support dynamic dispatch.
type ILimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitContext differentiates from other interfaces.
	IsLimitContext()
}

type LimitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitContext() *LimitContext {
	var p = new(LimitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_limit
	return p
}

func (*LimitContext) IsLimitContext() {}

func NewLimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitContext {
	var p = new(LimitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_limit

	return p
}

func (s *LimitContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *LimitContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *LimitContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLimit(s)
	}
}

func (s *LimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLimit(s)
	}
}

func (p *CypherParser) Limit() (localctx ILimitContext) {
	localctx = NewLimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CypherParserRULE_limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(CypherParserLIMIT)
	}
	{
		p.SetState(656)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(657)
		p.Expression()
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *SortItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *SortItemContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *CypherParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CypherParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Expression()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(660)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(663)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(CypherParserASCENDING-69))|(1<<(CypherParserASC-69))|(1<<(CypherParserDESCENDING-69))|(1<<(CypherParserDESC-69)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IWhereContext is an interface to support dynamic dispatch.
type IWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereContext differentiates from other interfaces.
	IsWhereContext()
}

type WhereContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereContext() *WhereContext {
	var p = new(WhereContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_where
	return p
}

func (*WhereContext) IsWhereContext() {}

func NewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereContext {
	var p = new(WhereContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_where

	return p
}

func (s *WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *WhereContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *WhereContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterWhere(s)
	}
}

func (s *WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitWhere(s)
	}
}

func (p *CypherParser) Where() (localctx IWhereContext) {
	localctx = NewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CypherParserRULE_where)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(CypherParserWHERE)
	}
	{
		p.SetState(667)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(668)
		p.Expression()
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllPatternPart() []IPatternPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternPartContext)(nil)).Elem())
	var tst = make([]IPatternPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternPartContext)
		}
	}

	return tst
}

func (s *PatternContext) PatternPart(i int) IPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternPartContext)
}

func (s *PatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *CypherParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CypherParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.PatternPart()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(672)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(671)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(674)
				p.Match(CypherParserT__1)
			}
			p.SetState(676)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(675)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(678)
				p.PatternPart()
			}

		}
		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// IPatternPartContext is an interface to support dynamic dispatch.
type IPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternPartContext differentiates from other interfaces.
	IsPatternPartContext()
}

type PatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternPartContext() *PatternPartContext {
	var p = new(PatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternPart
	return p
}

func (*PatternPartContext) IsPatternPartContext() {}

func NewPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternPartContext {
	var p = new(PatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternPart

	return p
}

func (s *PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternPartContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternPartContext) AnonymousPatternPart() IAnonymousPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousPatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousPatternPartContext)
}

func (s *PatternPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternPart(s)
	}
}

func (s *PatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternPart(s)
	}
}

func (p *CypherParser) PatternPart() (localctx IPatternPartContext) {
	localctx = NewPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CypherParserRULE_patternPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(695)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserALL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.Variable()
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(685)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(688)
			p.Match(CypherParserT__2)
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(689)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(692)
			p.AnonymousPatternPart()
		}

	case CypherParserT__6:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.AnonymousPatternPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnonymousPatternPartContext is an interface to support dynamic dispatch.
type IAnonymousPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymousPatternPartContext differentiates from other interfaces.
	IsAnonymousPatternPartContext()
}

type AnonymousPatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousPatternPartContext() *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_anonymousPatternPart
	return p
}

func (*AnonymousPatternPartContext) IsAnonymousPatternPartContext() {}

func NewAnonymousPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousPatternPartContext {
	var p = new(AnonymousPatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_anonymousPatternPart

	return p
}

func (s *AnonymousPatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousPatternPartContext) PatternElement() IPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *AnonymousPatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousPatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousPatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAnonymousPatternPart(s)
	}
}

func (s *AnonymousPatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAnonymousPatternPart(s)
	}
}

func (p *CypherParser) AnonymousPatternPart() (localctx IAnonymousPatternPartContext) {
	localctx = NewAnonymousPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CypherParserRULE_anonymousPatternPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.PatternElement()
	}

	return localctx
}

// IPatternElementContext is an interface to support dynamic dispatch.
type IPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementContext differentiates from other interfaces.
	IsPatternElementContext()
}

type PatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementContext() *PatternElementContext {
	var p = new(PatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElement
	return p
}

func (*PatternElementContext) IsPatternElementContext() {}

func NewPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementContext {
	var p = new(PatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElement

	return p
}

func (s *PatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementContext) AllPatternElementChain() []IPatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem())
	var tst = make([]IPatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternElementChainContext)
		}
	}

	return tst
}

func (s *PatternElementContext) PatternElementChain(i int) IPatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *PatternElementContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternElementContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternElementContext) PatternElement() IPatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternElementContext)
}

func (s *PatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternElement(s)
	}
}

func (s *PatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternElement(s)
	}
}

func (p *CypherParser) PatternElement() (localctx IPatternElementContext) {
	localctx = NewPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CypherParserRULE_patternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(699)
			p.NodePattern()
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(701)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(700)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(703)
					p.PatternElementChain()
				}

			}
			p.SetState(708)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(709)
			p.Match(CypherParserT__6)
		}
		{
			p.SetState(710)
			p.PatternElement()
		}
		{
			p.SetState(711)
			p.Match(CypherParserT__7)
		}

	}

	return localctx
}

// INodePatternContext is an interface to support dynamic dispatch.
type INodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodePatternContext differentiates from other interfaces.
	IsNodePatternContext()
}

type NodePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePatternContext() *NodePatternContext {
	var p = new(NodePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodePattern
	return p
}

func (*NodePatternContext) IsNodePatternContext() {}

func NewNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePatternContext {
	var p = new(NodePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodePattern

	return p
}

func (s *NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodePatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodePatternContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *NodePatternContext) NodeLabels() INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *NodePatternContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodePattern(s)
	}
}

func (s *NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodePattern(s)
	}
}

func (p *CypherParser) NodePattern() (localctx INodePatternContext) {
	localctx = NewNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CypherParserRULE_nodePattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Match(CypherParserT__6)
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(716)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserALL || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(CypherParserCOUNT-84))|(1<<(CypherParserFILTER-84))|(1<<(CypherParserEXTRACT-84))|(1<<(CypherParserANY-84))|(1<<(CypherParserNONE-84))|(1<<(CypherParserSINGLE-84))|(1<<(CypherParserHexLetter-84)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(719)
			p.Variable()
		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(720)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__10 {
		{
			p.SetState(725)
			p.NodeLabels()
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(726)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__24 || _la == CypherParserT__26 {
		{
			p.SetState(731)
			p.Properties()
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(732)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(737)
		p.Match(CypherParserT__7)
	}

	return localctx
}

// IPatternElementChainContext is an interface to support dynamic dispatch.
type IPatternElementChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternElementChainContext differentiates from other interfaces.
	IsPatternElementChainContext()
}

type PatternElementChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternElementChainContext() *PatternElementChainContext {
	var p = new(PatternElementChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternElementChain
	return p
}

func (*PatternElementChainContext) IsPatternElementChainContext() {}

func NewPatternElementChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternElementChainContext {
	var p = new(PatternElementChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternElementChain

	return p
}

func (s *PatternElementChainContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternElementChainContext) RelationshipPattern() IRelationshipPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipPatternContext)
}

func (s *PatternElementChainContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *PatternElementChainContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PatternElementChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternElementChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternElementChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternElementChain(s)
	}
}

func (s *PatternElementChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternElementChain(s)
	}
}

func (p *CypherParser) PatternElementChain() (localctx IPatternElementChainContext) {
	localctx = NewPatternElementChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CypherParserRULE_patternElementChain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.RelationshipPattern()
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(740)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(743)
		p.NodePattern()
	}

	return localctx
}

// IRelationshipPatternContext is an interface to support dynamic dispatch.
type IRelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipPatternContext differentiates from other interfaces.
	IsRelationshipPatternContext()
}

type RelationshipPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipPatternContext() *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipPattern
	return p
}

func (*RelationshipPatternContext) IsRelationshipPatternContext() {}

func NewRelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipPatternContext {
	var p = new(RelationshipPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipPattern

	return p
}

func (s *RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipPatternContext) LeftArrowHead() ILeftArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILeftArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILeftArrowHeadContext)
}

func (s *RelationshipPatternContext) AllDash() []IDashContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDashContext)(nil)).Elem())
	var tst = make([]IDashContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDashContext)
		}
	}

	return tst
}

func (s *RelationshipPatternContext) Dash(i int) IDashContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDashContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDashContext)
}

func (s *RelationshipPatternContext) RightArrowHead() IRightArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRightArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRightArrowHeadContext)
}

func (s *RelationshipPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipPatternContext) RelationshipDetail() IRelationshipDetailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipDetailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipDetailContext)
}

func (s *RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipPattern(s)
	}
}

func (s *RelationshipPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipPattern(s)
	}
}

func (p *CypherParser) RelationshipPattern() (localctx IRelationshipPatternContext) {
	localctx = NewRelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CypherParserRULE_relationshipPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(745)
			p.LeftArrowHead()
		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(746)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(749)
			p.Dash()
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(750)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__8 {
			{
				p.SetState(753)
				p.RelationshipDetail()
			}

		}
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(756)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(759)
			p.Dash()
		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(760)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(763)
			p.RightArrowHead()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.LeftArrowHead()
		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(766)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(769)
			p.Dash()
		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(770)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__8 {
			{
				p.SetState(773)
				p.RelationshipDetail()
			}

		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(776)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(779)
			p.Dash()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(781)
			p.Dash()
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(782)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__8 {
			{
				p.SetState(785)
				p.RelationshipDetail()
			}

		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(788)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(791)
			p.Dash()
		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(792)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(795)
			p.RightArrowHead()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(797)
			p.Dash()
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(798)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__8 {
			{
				p.SetState(801)
				p.RelationshipDetail()
			}

		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(804)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(807)
			p.Dash()
		}

	}

	return localctx
}

// IRelationshipDetailContext is an interface to support dynamic dispatch.
type IRelationshipDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipDetailContext differentiates from other interfaces.
	IsRelationshipDetailContext()
}

type RelationshipDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipDetailContext() *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipDetail
	return p
}

func (*RelationshipDetailContext) IsRelationshipDetailContext() {}

func NewRelationshipDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipDetailContext {
	var p = new(RelationshipDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipDetail

	return p
}

func (s *RelationshipDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipDetailContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipDetailContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipDetailContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RelationshipDetailContext) RelationshipTypes() IRelationshipTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipTypesContext)
}

func (s *RelationshipDetailContext) RangeLiteral() IRangeLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRangeLiteralContext)
}

func (s *RelationshipDetailContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RelationshipDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipDetail(s)
	}
}

func (s *RelationshipDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipDetail(s)
	}
}

func (p *CypherParser) RelationshipDetail() (localctx IRelationshipDetailContext) {
	localctx = NewRelationshipDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CypherParserRULE_relationshipDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Match(CypherParserT__8)
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(812)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserALL || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(CypherParserCOUNT-84))|(1<<(CypherParserFILTER-84))|(1<<(CypherParserEXTRACT-84))|(1<<(CypherParserANY-84))|(1<<(CypherParserNONE-84))|(1<<(CypherParserSINGLE-84))|(1<<(CypherParserHexLetter-84)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(815)
			p.Variable()
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(816)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__10 {
		{
			p.SetState(821)
			p.RelationshipTypes()
		}
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(822)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__5 {
		{
			p.SetState(827)
			p.RangeLiteral()
		}

	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__24 || _la == CypherParserT__26 {
		{
			p.SetState(830)
			p.Properties()
		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(831)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(836)
		p.Match(CypherParserT__9)
	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) MapLiteral() IMapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PropertiesContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (p *CypherParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CypherParserRULE_properties)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(840)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(838)
			p.MapLiteral()
		}

	case CypherParserT__26:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(839)
			p.Parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRelationshipTypesContext is an interface to support dynamic dispatch.
type IRelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipTypesContext differentiates from other interfaces.
	IsRelationshipTypesContext()
}

type RelationshipTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipTypesContext() *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipTypes
	return p
}

func (*RelationshipTypesContext) IsRelationshipTypesContext() {}

func NewRelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipTypesContext {
	var p = new(RelationshipTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipTypes

	return p
}

func (s *RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipTypesContext) AllRelTypeName() []IRelTypeNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelTypeNameContext)(nil)).Elem())
	var tst = make([]IRelTypeNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelTypeNameContext)
		}
	}

	return tst
}

func (s *RelationshipTypesContext) RelTypeName(i int) IRelTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelTypeNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelTypeNameContext)
}

func (s *RelationshipTypesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipTypesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipTypes(s)
	}
}

func (s *RelationshipTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipTypes(s)
	}
}

func (p *CypherParser) RelationshipTypes() (localctx IRelationshipTypesContext) {
	localctx = NewRelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CypherParserRULE_relationshipTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(CypherParserT__10)
	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(843)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(846)
		p.RelTypeName()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(848)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(847)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(850)
				p.Match(CypherParserT__11)
			}
			p.SetState(852)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserT__10 {
				{
					p.SetState(851)
					p.Match(CypherParserT__10)
				}

			}
			p.SetState(855)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(854)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(857)
				p.RelTypeName()
			}

		}
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// INodeLabelsContext is an interface to support dynamic dispatch.
type INodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelsContext differentiates from other interfaces.
	IsNodeLabelsContext()
}

type NodeLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelsContext() *NodeLabelsContext {
	var p = new(NodeLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabels
	return p
}

func (*NodeLabelsContext) IsNodeLabelsContext() {}

func NewNodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelsContext {
	var p = new(NodeLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabels

	return p
}

func (s *NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelsContext) AllNodeLabel() []INodeLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INodeLabelContext)(nil)).Elem())
	var tst = make([]INodeLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INodeLabelContext)
		}
	}

	return tst
}

func (s *NodeLabelsContext) NodeLabel(i int) INodeLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INodeLabelContext)
}

func (s *NodeLabelsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NodeLabelsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeLabels(s)
	}
}

func (s *NodeLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeLabels(s)
	}
}

func (p *CypherParser) NodeLabels() (localctx INodeLabelsContext) {
	localctx = NewNodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CypherParserRULE_nodeLabels)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.NodeLabel()
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(865)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(864)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(867)
				p.NodeLabel()
			}

		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}

	return localctx
}

// INodeLabelContext is an interface to support dynamic dispatch.
type INodeLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodeLabelContext differentiates from other interfaces.
	IsNodeLabelContext()
}

type NodeLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeLabelContext() *NodeLabelContext {
	var p = new(NodeLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_nodeLabel
	return p
}

func (*NodeLabelContext) IsNodeLabelContext() {}

func NewNodeLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeLabelContext {
	var p = new(NodeLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_nodeLabel

	return p
}

func (s *NodeLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeLabelContext) LabelName() ILabelNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *NodeLabelContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *NodeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNodeLabel(s)
	}
}

func (s *NodeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNodeLabel(s)
	}
}

func (p *CypherParser) NodeLabel() (localctx INodeLabelContext) {
	localctx = NewNodeLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CypherParserRULE_nodeLabel)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(CypherParserT__10)
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(874)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(877)
		p.LabelName()
	}

	return localctx
}

// IRangeLiteralContext is an interface to support dynamic dispatch.
type IRangeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeLiteralContext differentiates from other interfaces.
	IsRangeLiteralContext()
}

type RangeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeLiteralContext() *RangeLiteralContext {
	var p = new(RangeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rangeLiteral
	return p
}

func (*RangeLiteralContext) IsRangeLiteralContext() {}

func NewRangeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeLiteralContext {
	var p = new(RangeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rangeLiteral

	return p
}

func (s *RangeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RangeLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RangeLiteralContext) AllIntegerLiteral() []IIntegerLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem())
	var tst = make([]IIntegerLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntegerLiteralContext)
		}
	}

	return tst
}

func (s *RangeLiteralContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RangeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRangeLiteral(s)
	}
}

func (s *RangeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRangeLiteral(s)
	}
}

func (p *CypherParser) RangeLiteral() (localctx IRangeLiteralContext) {
	localctx = NewRangeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CypherParserRULE_rangeLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(CypherParserT__5)
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(880)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(CypherParserHexInteger-100))|(1<<(CypherParserDecimalInteger-100))|(1<<(CypherParserOctalInteger-100)))) != 0 {
		{
			p.SetState(883)
			p.IntegerLiteral()
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(884)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserT__12 {
		{
			p.SetState(889)
			p.Match(CypherParserT__12)
		}
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(890)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(CypherParserHexInteger-100))|(1<<(CypherParserDecimalInteger-100))|(1<<(CypherParserOctalInteger-100)))) != 0 {
			{
				p.SetState(893)
				p.IntegerLiteral()
			}
			p.SetState(895)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(894)
					p.Match(CypherParserSP)
				}

			}

		}

	}

	return localctx
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_labelName
	return p
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (p *CypherParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CypherParserRULE_labelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.SchemaName()
	}

	return localctx
}

// IRelTypeNameContext is an interface to support dynamic dispatch.
type IRelTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelTypeNameContext differentiates from other interfaces.
	IsRelTypeNameContext()
}

type RelTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelTypeNameContext() *RelTypeNameContext {
	var p = new(RelTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relTypeName
	return p
}

func (*RelTypeNameContext) IsRelTypeNameContext() {}

func NewRelTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelTypeNameContext {
	var p = new(RelTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relTypeName

	return p
}

func (s *RelTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RelTypeNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *RelTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelTypeName(s)
	}
}

func (s *RelTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelTypeName(s)
	}
}

func (p *CypherParser) RelTypeName() (localctx IRelTypeNameContext) {
	localctx = NewRelTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CypherParserRULE_relTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.SchemaName()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) OrExpression() IOrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *CypherParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CypherParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.OrExpression()
	}

	return localctx
}

// IOrExpressionContext is an interface to support dynamic dispatch.
type IOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrExpressionContext differentiates from other interfaces.
	IsOrExpressionContext()
}

type OrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExpressionContext() *OrExpressionContext {
	var p = new(OrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_orExpression
	return p
}

func (*OrExpressionContext) IsOrExpressionContext() {}

func NewOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExpressionContext {
	var p = new(OrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_orExpression

	return p
}

func (s *OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExpressionContext) AllXorExpression() []IXorExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXorExpressionContext)(nil)).Elem())
	var tst = make([]IXorExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXorExpressionContext)
		}
	}

	return tst
}

func (s *OrExpressionContext) XorExpression(i int) IXorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXorExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXorExpressionContext)
}

func (s *OrExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OrExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserOR)
}

func (s *OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserOR, i)
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOrExpression(s)
	}
}

func (s *OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOrExpression(s)
	}
}

func (p *CypherParser) OrExpression() (localctx IOrExpressionContext) {
	localctx = NewOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CypherParserRULE_orExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.XorExpression()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(908)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(909)
				p.Match(CypherParserOR)
			}
			{
				p.SetState(910)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(911)
				p.XorExpression()
			}

		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
	}

	return localctx
}

// IXorExpressionContext is an interface to support dynamic dispatch.
type IXorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXorExpressionContext differentiates from other interfaces.
	IsXorExpressionContext()
}

type XorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXorExpressionContext() *XorExpressionContext {
	var p = new(XorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_xorExpression
	return p
}

func (*XorExpressionContext) IsXorExpressionContext() {}

func NewXorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XorExpressionContext {
	var p = new(XorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_xorExpression

	return p
}

func (s *XorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *XorExpressionContext) AllAndExpression() []IAndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndExpressionContext)(nil)).Elem())
	var tst = make([]IAndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndExpressionContext)
		}
	}

	return tst
}

func (s *XorExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *XorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *XorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *XorExpressionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserXOR)
}

func (s *XorExpressionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, i)
}

func (s *XorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterXorExpression(s)
	}
}

func (s *XorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitXorExpression(s)
	}
}

func (p *CypherParser) XorExpression() (localctx IXorExpressionContext) {
	localctx = NewXorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CypherParserRULE_xorExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.AndExpression()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(918)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(919)
				p.Match(CypherParserXOR)
			}
			{
				p.SetState(920)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(921)
				p.AndExpression()
			}

		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}

	return localctx
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_andExpression
	return p
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllNotExpression() []INotExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INotExpressionContext)(nil)).Elem())
	var tst = make([]INotExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INotExpressionContext)
		}
	}

	return tst
}

func (s *AndExpressionContext) NotExpression(i int) INotExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *AndExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AndExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(CypherParserAND)
}

func (s *AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserAND, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (p *CypherParser) AndExpression() (localctx IAndExpressionContext) {
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CypherParserRULE_andExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.NotExpression()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(928)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(929)
				p.Match(CypherParserAND)
			}
			{
				p.SetState(930)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(931)
				p.NotExpression()
			}

		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// INotExpressionContext is an interface to support dynamic dispatch.
type INotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotExpressionContext differentiates from other interfaces.
	IsNotExpressionContext()
}

type NotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExpressionContext() *NotExpressionContext {
	var p = new(NotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_notExpression
	return p
}

func (*NotExpressionContext) IsNotExpressionContext() {}

func NewNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_notExpression

	return p
}

func (s *NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExpressionContext) ComparisonExpression() IComparisonExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *NotExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *NotExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *NotExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *NotExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (p *CypherParser) NotExpression() (localctx INotExpressionContext) {
	localctx = NewNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CypherParserRULE_notExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserNOT {
		{
			p.SetState(937)
			p.Match(CypherParserNOT)
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(938)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(946)
		p.ComparisonExpression()
	}

	return localctx
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_comparisonExpression
	return p
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) AddOrSubtractExpression() IAddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrSubtractExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExpressionContext)
}

func (s *ComparisonExpressionContext) AllPartialComparisonExpression() []IPartialComparisonExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartialComparisonExpressionContext)(nil)).Elem())
	var tst = make([]IPartialComparisonExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartialComparisonExpressionContext)
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) PartialComparisonExpression(i int) IPartialComparisonExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialComparisonExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartialComparisonExpressionContext)
}

func (s *ComparisonExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ComparisonExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (p *CypherParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CypherParserRULE_comparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.AddOrSubtractExpression()
	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(950)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(949)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(952)
				p.PartialComparisonExpression()
			}

		}
		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())
	}

	return localctx
}

// IAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOrSubtractExpressionContext differentiates from other interfaces.
	IsAddOrSubtractExpressionContext()
}

type AddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOrSubtractExpressionContext() *AddOrSubtractExpressionContext {
	var p = new(AddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_addOrSubtractExpression
	return p
}

func (*AddOrSubtractExpressionContext) IsAddOrSubtractExpressionContext() {}

func NewAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOrSubtractExpressionContext {
	var p = new(AddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_addOrSubtractExpression

	return p
}

func (s *AddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOrSubtractExpressionContext) AllMultiplyDivideModuloExpression() []IMultiplyDivideModuloExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyDivideModuloExpressionContext)(nil)).Elem())
	var tst = make([]IMultiplyDivideModuloExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyDivideModuloExpressionContext)
		}
	}

	return tst
}

func (s *AddOrSubtractExpressionContext) MultiplyDivideModuloExpression(i int) IMultiplyDivideModuloExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyDivideModuloExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyDivideModuloExpressionContext)
}

func (s *AddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAddOrSubtractExpression(s)
	}
}

func (s *AddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAddOrSubtractExpression(s)
	}
}

func (p *CypherParser) AddOrSubtractExpression() (localctx IAddOrSubtractExpressionContext) {
	localctx = NewAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CypherParserRULE_addOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.MultiplyDivideModuloExpression()
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(975)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
			case 1:
				p.SetState(960)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(959)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(962)
					p.Match(CypherParserT__13)
				}
				p.SetState(964)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(963)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(966)
					p.MultiplyDivideModuloExpression()
				}

			case 2:
				p.SetState(968)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(967)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(970)
					p.Match(CypherParserT__4)
				}
				p.SetState(972)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(971)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(974)
					p.MultiplyDivideModuloExpression()
				}

			}

		}
		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())
	}

	return localctx
}

// IMultiplyDivideModuloExpressionContext is an interface to support dynamic dispatch.
type IMultiplyDivideModuloExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyDivideModuloExpressionContext differentiates from other interfaces.
	IsMultiplyDivideModuloExpressionContext()
}

type MultiplyDivideModuloExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyDivideModuloExpressionContext() *MultiplyDivideModuloExpressionContext {
	var p = new(MultiplyDivideModuloExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpression
	return p
}

func (*MultiplyDivideModuloExpressionContext) IsMultiplyDivideModuloExpressionContext() {}

func NewMultiplyDivideModuloExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyDivideModuloExpressionContext {
	var p = new(MultiplyDivideModuloExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_multiplyDivideModuloExpression

	return p
}

func (s *MultiplyDivideModuloExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyDivideModuloExpressionContext) AllPowerOfExpression() []IPowerOfExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPowerOfExpressionContext)(nil)).Elem())
	var tst = make([]IPowerOfExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPowerOfExpressionContext)
		}
	}

	return tst
}

func (s *MultiplyDivideModuloExpressionContext) PowerOfExpression(i int) IPowerOfExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerOfExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPowerOfExpressionContext)
}

func (s *MultiplyDivideModuloExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MultiplyDivideModuloExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MultiplyDivideModuloExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyDivideModuloExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyDivideModuloExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMultiplyDivideModuloExpression(s)
	}
}

func (s *MultiplyDivideModuloExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMultiplyDivideModuloExpression(s)
	}
}

func (p *CypherParser) MultiplyDivideModuloExpression() (localctx IMultiplyDivideModuloExpressionContext) {
	localctx = NewMultiplyDivideModuloExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CypherParserRULE_multiplyDivideModuloExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.PowerOfExpression()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1005)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
			case 1:
				p.SetState(982)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(981)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(984)
					p.Match(CypherParserT__5)
				}
				p.SetState(986)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(985)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(988)
					p.PowerOfExpression()
				}

			case 2:
				p.SetState(990)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(989)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(992)
					p.Match(CypherParserT__14)
				}
				p.SetState(994)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(993)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(996)
					p.PowerOfExpression()
				}

			case 3:
				p.SetState(998)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(997)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1000)
					p.Match(CypherParserT__15)
				}
				p.SetState(1002)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1001)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1004)
					p.PowerOfExpression()
				}

			}

		}
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())
	}

	return localctx
}

// IPowerOfExpressionContext is an interface to support dynamic dispatch.
type IPowerOfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerOfExpressionContext differentiates from other interfaces.
	IsPowerOfExpressionContext()
}

type PowerOfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerOfExpressionContext() *PowerOfExpressionContext {
	var p = new(PowerOfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_powerOfExpression
	return p
}

func (*PowerOfExpressionContext) IsPowerOfExpressionContext() {}

func NewPowerOfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerOfExpressionContext {
	var p = new(PowerOfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_powerOfExpression

	return p
}

func (s *PowerOfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerOfExpressionContext) AllUnaryAddOrSubtractExpression() []IUnaryAddOrSubtractExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnaryAddOrSubtractExpressionContext)(nil)).Elem())
	var tst = make([]IUnaryAddOrSubtractExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnaryAddOrSubtractExpressionContext)
		}
	}

	return tst
}

func (s *PowerOfExpressionContext) UnaryAddOrSubtractExpression(i int) IUnaryAddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryAddOrSubtractExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnaryAddOrSubtractExpressionContext)
}

func (s *PowerOfExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PowerOfExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PowerOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerOfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPowerOfExpression(s)
	}
}

func (s *PowerOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPowerOfExpression(s)
	}
}

func (p *CypherParser) PowerOfExpression() (localctx IPowerOfExpressionContext) {
	localctx = NewPowerOfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CypherParserRULE_powerOfExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		p.UnaryAddOrSubtractExpression()
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1012)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1011)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1014)
				p.Match(CypherParserT__16)
			}
			p.SetState(1016)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1015)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1018)
				p.UnaryAddOrSubtractExpression()
			}

		}
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IUnaryAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryAddOrSubtractExpressionContext differentiates from other interfaces.
	IsUnaryAddOrSubtractExpressionContext()
}

type UnaryAddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryAddOrSubtractExpressionContext() *UnaryAddOrSubtractExpressionContext {
	var p = new(UnaryAddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpression
	return p
}

func (*UnaryAddOrSubtractExpressionContext) IsUnaryAddOrSubtractExpressionContext() {}

func NewUnaryAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryAddOrSubtractExpressionContext {
	var p = new(UnaryAddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_unaryAddOrSubtractExpression

	return p
}

func (s *UnaryAddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryAddOrSubtractExpressionContext) StringListNullOperatorExpression() IStringListNullOperatorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringListNullOperatorExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringListNullOperatorExpressionContext)
}

func (s *UnaryAddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *UnaryAddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *UnaryAddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryAddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterUnaryAddOrSubtractExpression(s)
	}
}

func (s *UnaryAddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitUnaryAddOrSubtractExpression(s)
	}
}

func (p *CypherParser) UnaryAddOrSubtractExpression() (localctx IUnaryAddOrSubtractExpressionContext) {
	localctx = NewUnaryAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CypherParserRULE_unaryAddOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == CypherParserT__4 || _la == CypherParserT__13 {
		p.SetState(1024)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserT__4 || _la == CypherParserT__13) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1025)
				p.Match(CypherParserSP)
			}

		}

		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1033)
		p.StringListNullOperatorExpression()
	}

	return localctx
}

// IStringListNullOperatorExpressionContext is an interface to support dynamic dispatch.
type IStringListNullOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringListNullOperatorExpressionContext differentiates from other interfaces.
	IsStringListNullOperatorExpressionContext()
}

type StringListNullOperatorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListNullOperatorExpressionContext() *StringListNullOperatorExpressionContext {
	var p = new(StringListNullOperatorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpression
	return p
}

func (*StringListNullOperatorExpressionContext) IsStringListNullOperatorExpressionContext() {}

func NewStringListNullOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListNullOperatorExpressionContext {
	var p = new(StringListNullOperatorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_stringListNullOperatorExpression

	return p
}

func (s *StringListNullOperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListNullOperatorExpressionContext) AllPropertyOrLabelsExpression() []IPropertyOrLabelsExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyOrLabelsExpressionContext)(nil)).Elem())
	var tst = make([]IPropertyOrLabelsExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyOrLabelsExpressionContext)
		}
	}

	return tst
}

func (s *StringListNullOperatorExpressionContext) PropertyOrLabelsExpression(i int) IPropertyOrLabelsExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyOrLabelsExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyOrLabelsExpressionContext)
}

func (s *StringListNullOperatorExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StringListNullOperatorExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StringListNullOperatorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *StringListNullOperatorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *StringListNullOperatorExpressionContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserIS)
}

func (s *StringListNullOperatorExpressionContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserIS, i)
}

func (s *StringListNullOperatorExpressionContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNULL)
}

func (s *StringListNullOperatorExpressionContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, i)
}

func (s *StringListNullOperatorExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *StringListNullOperatorExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *StringListNullOperatorExpressionContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(CypherParserIN)
}

func (s *StringListNullOperatorExpressionContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserIN, i)
}

func (s *StringListNullOperatorExpressionContext) AllSTARTS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSTARTS)
}

func (s *StringListNullOperatorExpressionContext) STARTS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, i)
}

func (s *StringListNullOperatorExpressionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(CypherParserWITH)
}

func (s *StringListNullOperatorExpressionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, i)
}

func (s *StringListNullOperatorExpressionContext) AllENDS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserENDS)
}

func (s *StringListNullOperatorExpressionContext) ENDS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, i)
}

func (s *StringListNullOperatorExpressionContext) AllCONTAINS() []antlr.TerminalNode {
	return s.GetTokens(CypherParserCONTAINS)
}

func (s *StringListNullOperatorExpressionContext) CONTAINS(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, i)
}

func (s *StringListNullOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListNullOperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListNullOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterStringListNullOperatorExpression(s)
	}
}

func (s *StringListNullOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitStringListNullOperatorExpression(s)
	}
}

func (p *CypherParser) StringListNullOperatorExpression() (localctx IStringListNullOperatorExpressionContext) {
	localctx = NewStringListNullOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CypherParserRULE_stringListNullOperatorExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.PropertyOrLabelsExpression()
	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1087)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1037)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1036)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1039)
					p.Match(CypherParserT__8)
				}
				{
					p.SetState(1040)
					p.Expression()
				}
				{
					p.SetState(1041)
					p.Match(CypherParserT__9)
				}

			case 2:
				p.SetState(1044)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1043)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1046)
					p.Match(CypherParserT__8)
				}
				p.SetState(1048)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__4)|(1<<CypherParserT__6)|(1<<CypherParserT__8)|(1<<CypherParserT__13)|(1<<CypherParserT__24)|(1<<CypherParserT__26))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserNULL-83))|(1<<(CypherParserCOUNT-83))|(1<<(CypherParserFILTER-83))|(1<<(CypherParserEXTRACT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserTRUE-83))|(1<<(CypherParserFALSE-83))|(1<<(CypherParserEXISTS-83))|(1<<(CypherParserCASE-83))|(1<<(CypherParserStringLiteral-83))|(1<<(CypherParserHexInteger-83))|(1<<(CypherParserDecimalInteger-83))|(1<<(CypherParserOctalInteger-83))|(1<<(CypherParserHexLetter-83))|(1<<(CypherParserExponentDecimalReal-83))|(1<<(CypherParserRegularDecimalReal-83)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
					{
						p.SetState(1047)
						p.Expression()
					}

				}
				{
					p.SetState(1050)
					p.Match(CypherParserT__12)
				}
				p.SetState(1052)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__4)|(1<<CypherParserT__6)|(1<<CypherParserT__8)|(1<<CypherParserT__13)|(1<<CypherParserT__24)|(1<<CypherParserT__26))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserNULL-83))|(1<<(CypherParserCOUNT-83))|(1<<(CypherParserFILTER-83))|(1<<(CypherParserEXTRACT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserTRUE-83))|(1<<(CypherParserFALSE-83))|(1<<(CypherParserEXISTS-83))|(1<<(CypherParserCASE-83))|(1<<(CypherParserStringLiteral-83))|(1<<(CypherParserHexInteger-83))|(1<<(CypherParserDecimalInteger-83))|(1<<(CypherParserOctalInteger-83))|(1<<(CypherParserHexLetter-83))|(1<<(CypherParserExponentDecimalReal-83))|(1<<(CypherParserRegularDecimalReal-83)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
					{
						p.SetState(1051)
						p.Expression()
					}

				}
				{
					p.SetState(1054)
					p.Match(CypherParserT__9)
				}

			case 3:
				p.SetState(1071)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
				case 1:
					p.SetState(1056)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == CypherParserSP {
						{
							p.SetState(1055)
							p.Match(CypherParserSP)
						}

					}
					{
						p.SetState(1058)
						p.Match(CypherParserT__17)
					}

				case 2:
					{
						p.SetState(1059)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1060)
						p.Match(CypherParserIN)
					}

				case 3:
					{
						p.SetState(1061)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1062)
						p.Match(CypherParserSTARTS)
					}
					{
						p.SetState(1063)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1064)
						p.Match(CypherParserWITH)
					}

				case 4:
					{
						p.SetState(1065)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1066)
						p.Match(CypherParserENDS)
					}
					{
						p.SetState(1067)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1068)
						p.Match(CypherParserWITH)
					}

				case 5:
					{
						p.SetState(1069)
						p.Match(CypherParserSP)
					}
					{
						p.SetState(1070)
						p.Match(CypherParserCONTAINS)
					}

				}
				p.SetState(1074)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1073)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1076)
					p.PropertyOrLabelsExpression()
				}

			case 4:
				{
					p.SetState(1077)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(1078)
					p.Match(CypherParserIS)
				}
				{
					p.SetState(1079)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(1080)
					p.Match(CypherParserNULL)
				}

			case 5:
				{
					p.SetState(1081)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(1082)
					p.Match(CypherParserIS)
				}
				{
					p.SetState(1083)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(1084)
					p.Match(CypherParserNOT)
				}
				{
					p.SetState(1085)
					p.Match(CypherParserSP)
				}
				{
					p.SetState(1086)
					p.Match(CypherParserNULL)
				}

			}

		}
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyOrLabelsExpressionContext is an interface to support dynamic dispatch.
type IPropertyOrLabelsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyOrLabelsExpressionContext differentiates from other interfaces.
	IsPropertyOrLabelsExpressionContext()
}

type PropertyOrLabelsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyOrLabelsExpressionContext() *PropertyOrLabelsExpressionContext {
	var p = new(PropertyOrLabelsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpression
	return p
}

func (*PropertyOrLabelsExpressionContext) IsPropertyOrLabelsExpressionContext() {}

func NewPropertyOrLabelsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyOrLabelsExpressionContext {
	var p = new(PropertyOrLabelsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyOrLabelsExpression

	return p
}

func (s *PropertyOrLabelsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyOrLabelsExpressionContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyOrLabelsExpressionContext) AllPropertyLookup() []IPropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem())
	var tst = make([]IPropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyLookupContext)
		}
	}

	return tst
}

func (s *PropertyOrLabelsExpressionContext) PropertyLookup(i int) IPropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyOrLabelsExpressionContext) AllNodeLabels() []INodeLabelsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem())
	var tst = make([]INodeLabelsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INodeLabelsContext)
		}
	}

	return tst
}

func (s *PropertyOrLabelsExpressionContext) NodeLabels(i int) INodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodeLabelsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INodeLabelsContext)
}

func (s *PropertyOrLabelsExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyOrLabelsExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyOrLabelsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyOrLabelsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyOrLabelsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyOrLabelsExpression(s)
	}
}

func (s *PropertyOrLabelsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyOrLabelsExpression(s)
	}
}

func (p *CypherParser) PropertyOrLabelsExpression() (localctx IPropertyOrLabelsExpressionContext) {
	localctx = NewPropertyOrLabelsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CypherParserRULE_propertyOrLabelsExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.Atom()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1094)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1093)
					p.Match(CypherParserSP)
				}

			}
			p.SetState(1098)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case CypherParserT__23:
				{
					p.SetState(1096)
					p.PropertyLookup()
				}

			case CypherParserT__10:
				{
					p.SetState(1097)
					p.NodeLabels()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Parameter() IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *AtomContext) CaseExpression() ICaseExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *AtomContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *AtomContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *AtomContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *AtomContext) ListComprehension() IListComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListComprehensionContext)
}

func (s *AtomContext) PatternComprehension() IPatternComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternComprehensionContext)
}

func (s *AtomContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *AtomContext) FilterExpression() IFilterExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *AtomContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *AtomContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AtomContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *AtomContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *AtomContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *AtomContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *AtomContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *AtomContext) FunctionInvocation() IFunctionInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionInvocationContext)
}

func (s *AtomContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *CypherParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CypherParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1105)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.Parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1107)
			p.CaseExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1108)
			p.Match(CypherParserCOUNT)
		}
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1109)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1112)
			p.Match(CypherParserT__6)
		}
		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1113)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1116)
			p.Match(CypherParserT__5)
		}
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1117)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1120)
			p.Match(CypherParserT__7)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1121)
			p.ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1122)
			p.PatternComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1123)
			p.Match(CypherParserFILTER)
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1124)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1127)
			p.Match(CypherParserT__6)
		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1128)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1131)
			p.FilterExpression()
		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1132)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1135)
			p.Match(CypherParserT__7)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1137)
			p.Match(CypherParserEXTRACT)
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1138)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1141)
			p.Match(CypherParserT__6)
		}
		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1142)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1145)
			p.FilterExpression()
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1146)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserT__11 || _la == CypherParserSP {
			p.SetState(1150)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1149)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1152)
				p.Match(CypherParserT__11)
			}
			{
				p.SetState(1153)
				p.Expression()
			}

		}
		{
			p.SetState(1156)
			p.Match(CypherParserT__7)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1158)
			p.Match(CypherParserALL)
		}
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1159)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1162)
			p.Match(CypherParserT__6)
		}
		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1163)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1166)
			p.FilterExpression()
		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1167)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1170)
			p.Match(CypherParserT__7)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1172)
			p.Match(CypherParserANY)
		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1173)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1176)
			p.Match(CypherParserT__6)
		}
		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1177)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1180)
			p.FilterExpression()
		}
		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1181)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1184)
			p.Match(CypherParserT__7)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1186)
			p.Match(CypherParserNONE)
		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1187)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1190)
			p.Match(CypherParserT__6)
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1191)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1194)
			p.FilterExpression()
		}
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1195)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1198)
			p.Match(CypherParserT__7)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1200)
			p.Match(CypherParserSINGLE)
		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1201)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1204)
			p.Match(CypherParserT__6)
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1205)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1208)
			p.FilterExpression()
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1209)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1212)
			p.Match(CypherParserT__7)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1214)
			p.RelationshipsPattern()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1215)
			p.ParenthesizedExpression()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1216)
			p.FunctionInvocation()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1217)
			p.Variable()
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *LiteralContext) MapLiteral() IMapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LiteralContext) ListLiteral() IListLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *CypherParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CypherParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1226)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.NumberLiteral()
		}

	case CypherParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1221)
			p.Match(CypherParserStringLiteral)
		}

	case CypherParserTRUE, CypherParserFALSE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1222)
			p.BooleanLiteral()
		}

	case CypherParserNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1223)
			p.Match(CypherParserNULL)
		}

	case CypherParserT__24:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1224)
			p.MapLiteral()
		}

	case CypherParserT__8:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1225)
			p.ListLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *CypherParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CypherParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1228)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserTRUE || _la == CypherParserFALSE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listLiteral
	return p
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListLiteralContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ListLiteralContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterListLiteral(s)
	}
}

func (s *ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitListLiteral(s)
	}
}

func (p *CypherParser) ListLiteral() (localctx IListLiteralContext) {
	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CypherParserRULE_listLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(CypherParserT__8)
	}
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1231)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__4)|(1<<CypherParserT__6)|(1<<CypherParserT__8)|(1<<CypherParserT__13)|(1<<CypherParserT__24)|(1<<CypherParserT__26))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserNULL-83))|(1<<(CypherParserCOUNT-83))|(1<<(CypherParserFILTER-83))|(1<<(CypherParserEXTRACT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserTRUE-83))|(1<<(CypherParserFALSE-83))|(1<<(CypherParserEXISTS-83))|(1<<(CypherParserCASE-83))|(1<<(CypherParserStringLiteral-83))|(1<<(CypherParserHexInteger-83))|(1<<(CypherParserDecimalInteger-83))|(1<<(CypherParserOctalInteger-83))|(1<<(CypherParserHexLetter-83))|(1<<(CypherParserExponentDecimalReal-83))|(1<<(CypherParserRegularDecimalReal-83)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(1234)
			p.Expression()
		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1235)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1238)
				p.Match(CypherParserT__1)
			}
			p.SetState(1240)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1239)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1242)
				p.Expression()
			}
			p.SetState(1244)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1243)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1250)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1253)
		p.Match(CypherParserT__9)
	}

	return localctx
}

// IPartialComparisonExpressionContext is an interface to support dynamic dispatch.
type IPartialComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialComparisonExpressionContext differentiates from other interfaces.
	IsPartialComparisonExpressionContext()
}

type PartialComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialComparisonExpressionContext() *PartialComparisonExpressionContext {
	var p = new(PartialComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_partialComparisonExpression
	return p
}

func (*PartialComparisonExpressionContext) IsPartialComparisonExpressionContext() {}

func NewPartialComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialComparisonExpressionContext {
	var p = new(PartialComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_partialComparisonExpression

	return p
}

func (s *PartialComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialComparisonExpressionContext) AddOrSubtractExpression() IAddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrSubtractExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrSubtractExpressionContext)
}

func (s *PartialComparisonExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PartialComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPartialComparisonExpression(s)
	}
}

func (s *PartialComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPartialComparisonExpression(s)
	}
}

func (p *CypherParser) PartialComparisonExpression() (localctx IPartialComparisonExpressionContext) {
	localctx = NewPartialComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CypherParserRULE_partialComparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1255)
			p.Match(CypherParserT__2)
		}
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1256)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1259)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1260)
			p.Match(CypherParserT__18)
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1261)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1264)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__19:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1265)
			p.Match(CypherParserT__19)
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1266)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1269)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__20:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1270)
			p.Match(CypherParserT__20)
		}
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1271)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1274)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__21:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1275)
			p.Match(CypherParserT__21)
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1276)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1279)
			p.AddOrSubtractExpression()
		}

	case CypherParserT__22:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1280)
			p.Match(CypherParserT__22)
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1281)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1284)
			p.AddOrSubtractExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parenthesizedExpression
	return p
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ParenthesizedExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (p *CypherParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CypherParserRULE_parenthesizedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1287)
		p.Match(CypherParserT__6)
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1288)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1291)
		p.Expression()
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1292)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1295)
		p.Match(CypherParserT__7)
	}

	return localctx
}

// IRelationshipsPatternContext is an interface to support dynamic dispatch.
type IRelationshipsPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationshipsPatternContext differentiates from other interfaces.
	IsRelationshipsPatternContext()
}

type RelationshipsPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationshipsPatternContext() *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_relationshipsPattern
	return p
}

func (*RelationshipsPatternContext) IsRelationshipsPatternContext() {}

func NewRelationshipsPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationshipsPatternContext {
	var p = new(RelationshipsPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_relationshipsPattern

	return p
}

func (s *RelationshipsPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationshipsPatternContext) NodePattern() INodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *RelationshipsPatternContext) AllPatternElementChain() []IPatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem())
	var tst = make([]IPatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternElementChainContext)
		}
	}

	return tst
}

func (s *RelationshipsPatternContext) PatternElementChain(i int) IPatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternElementChainContext)
}

func (s *RelationshipsPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *RelationshipsPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *RelationshipsPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationshipsPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationshipsPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRelationshipsPattern(s)
	}
}

func (s *RelationshipsPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRelationshipsPattern(s)
	}
}

func (p *CypherParser) RelationshipsPattern() (localctx IRelationshipsPatternContext) {
	localctx = NewRelationshipsPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CypherParserRULE_relationshipsPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.NodePattern()
	}
	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1299)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1298)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1301)
				p.PatternElementChain()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1304)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext())
	}

	return localctx
}

// IFilterExpressionContext is an interface to support dynamic dispatch.
type IFilterExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterExpressionContext differentiates from other interfaces.
	IsFilterExpressionContext()
}

type FilterExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterExpressionContext() *FilterExpressionContext {
	var p = new(FilterExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_filterExpression
	return p
}

func (*FilterExpressionContext) IsFilterExpressionContext() {}

func NewFilterExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterExpressionContext {
	var p = new(FilterExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_filterExpression

	return p
}

func (s *FilterExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterExpressionContext) IdInColl() IIdInCollContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdInCollContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdInCollContext)
}

func (s *FilterExpressionContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *FilterExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *FilterExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFilterExpression(s)
	}
}

func (s *FilterExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFilterExpression(s)
	}
}

func (p *CypherParser) FilterExpression() (localctx IFilterExpressionContext) {
	localctx = NewFilterExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CypherParserRULE_filterExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.IdInColl()
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext()) == 1 {
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1307)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1310)
			p.Where()
		}

	}

	return localctx
}

// IIdInCollContext is an interface to support dynamic dispatch.
type IIdInCollContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdInCollContext differentiates from other interfaces.
	IsIdInCollContext()
}

type IdInCollContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdInCollContext() *IdInCollContext {
	var p = new(IdInCollContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_idInColl
	return p
}

func (*IdInCollContext) IsIdInCollContext() {}

func NewIdInCollContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdInCollContext {
	var p = new(IdInCollContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_idInColl

	return p
}

func (s *IdInCollContext) GetParser() antlr.Parser { return s.parser }

func (s *IdInCollContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *IdInCollContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *IdInCollContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *IdInCollContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *IdInCollContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IdInCollContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdInCollContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdInCollContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIdInColl(s)
	}
}

func (s *IdInCollContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIdInColl(s)
	}
}

func (p *CypherParser) IdInColl() (localctx IIdInCollContext) {
	localctx = NewIdInCollContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CypherParserRULE_idInColl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1313)
		p.Variable()
	}
	{
		p.SetState(1314)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1315)
		p.Match(CypherParserIN)
	}
	{
		p.SetState(1316)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1317)
		p.Expression()
	}

	return localctx
}

// IFunctionInvocationContext is an interface to support dynamic dispatch.
type IFunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionInvocationContext differentiates from other interfaces.
	IsFunctionInvocationContext()
}

type FunctionInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionInvocationContext() *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionInvocation
	return p
}

func (*FunctionInvocationContext) IsFunctionInvocationContext() {}

func NewFunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionInvocation

	return p
}

func (s *FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionInvocationContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *FunctionInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *FunctionInvocationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionInvocationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunctionInvocation(s)
	}
}

func (s *FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunctionInvocation(s)
	}
}

func (p *CypherParser) FunctionInvocation() (localctx IFunctionInvocationContext) {
	localctx = NewFunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CypherParserRULE_functionInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1319)
		p.FunctionName()
	}
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1320)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1323)
		p.Match(CypherParserT__6)
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1324)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserDISTINCT {
		{
			p.SetState(1327)
			p.Match(CypherParserDISTINCT)
		}
		p.SetState(1329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1328)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__4)|(1<<CypherParserT__6)|(1<<CypherParserT__8)|(1<<CypherParserT__13)|(1<<CypherParserT__24)|(1<<CypherParserT__26))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserNULL-83))|(1<<(CypherParserCOUNT-83))|(1<<(CypherParserFILTER-83))|(1<<(CypherParserEXTRACT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserTRUE-83))|(1<<(CypherParserFALSE-83))|(1<<(CypherParserEXISTS-83))|(1<<(CypherParserCASE-83))|(1<<(CypherParserStringLiteral-83))|(1<<(CypherParserHexInteger-83))|(1<<(CypherParserDecimalInteger-83))|(1<<(CypherParserOctalInteger-83))|(1<<(CypherParserHexLetter-83))|(1<<(CypherParserExponentDecimalReal-83))|(1<<(CypherParserRegularDecimalReal-83)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(1333)
			p.Expression()
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1334)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1337)
				p.Match(CypherParserT__1)
			}
			p.SetState(1339)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1338)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1341)
				p.Expression()
			}
			p.SetState(1343)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1342)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1352)
		p.Match(CypherParserT__7)
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *FunctionNameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *CypherParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CypherParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1356)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserALL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1354)
			p.SymbolicName()
		}

	case CypherParserEXISTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1355)
			p.Match(CypherParserEXISTS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IExplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitProcedureInvocationContext differentiates from other interfaces.
	IsExplicitProcedureInvocationContext()
}

type ExplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitProcedureInvocationContext() *ExplicitProcedureInvocationContext {
	var p = new(ExplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_explicitProcedureInvocation
	return p
}

func (*ExplicitProcedureInvocationContext) IsExplicitProcedureInvocationContext() {}

func NewExplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitProcedureInvocationContext {
	var p = new(ExplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_explicitProcedureInvocation

	return p
}

func (s *ExplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitProcedureInvocationContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ExplicitProcedureInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ExplicitProcedureInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ExplicitProcedureInvocationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExplicitProcedureInvocationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterExplicitProcedureInvocation(s)
	}
}

func (s *ExplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitExplicitProcedureInvocation(s)
	}
}

func (p *CypherParser) ExplicitProcedureInvocation() (localctx IExplicitProcedureInvocationContext) {
	localctx = NewExplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CypherParserRULE_explicitProcedureInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.ProcedureName()
	}
	p.SetState(1360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1359)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1362)
		p.Match(CypherParserT__6)
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1363)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__4)|(1<<CypherParserT__6)|(1<<CypherParserT__8)|(1<<CypherParserT__13)|(1<<CypherParserT__24)|(1<<CypherParserT__26))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(CypherParserNULL-83))|(1<<(CypherParserCOUNT-83))|(1<<(CypherParserFILTER-83))|(1<<(CypherParserEXTRACT-83))|(1<<(CypherParserANY-83))|(1<<(CypherParserNONE-83))|(1<<(CypherParserSINGLE-83))|(1<<(CypherParserTRUE-83))|(1<<(CypherParserFALSE-83))|(1<<(CypherParserEXISTS-83))|(1<<(CypherParserCASE-83))|(1<<(CypherParserStringLiteral-83))|(1<<(CypherParserHexInteger-83))|(1<<(CypherParserDecimalInteger-83))|(1<<(CypherParserOctalInteger-83))|(1<<(CypherParserHexLetter-83))|(1<<(CypherParserExponentDecimalReal-83))|(1<<(CypherParserRegularDecimalReal-83)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(1366)
			p.Expression()
		}
		p.SetState(1368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1367)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1370)
				p.Match(CypherParserT__1)
			}
			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1371)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1374)
				p.Expression()
			}
			p.SetState(1376)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1375)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1382)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1385)
		p.Match(CypherParserT__7)
	}

	return localctx
}

// IImplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IImplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicitProcedureInvocationContext differentiates from other interfaces.
	IsImplicitProcedureInvocationContext()
}

type ImplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitProcedureInvocationContext() *ImplicitProcedureInvocationContext {
	var p = new(ImplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_implicitProcedureInvocation
	return p
}

func (*ImplicitProcedureInvocationContext) IsImplicitProcedureInvocationContext() {}

func NewImplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitProcedureInvocationContext {
	var p = new(ImplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_implicitProcedureInvocation

	return p
}

func (s *ImplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitProcedureInvocationContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *ImplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterImplicitProcedureInvocation(s)
	}
}

func (s *ImplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitImplicitProcedureInvocation(s)
	}
}

func (p *CypherParser) ImplicitProcedureInvocation() (localctx IImplicitProcedureInvocationContext) {
	localctx = NewImplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CypherParserRULE_implicitProcedureInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)
		p.ProcedureName()
	}

	return localctx
}

// IProcedureResultFieldContext is an interface to support dynamic dispatch.
type IProcedureResultFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureResultFieldContext differentiates from other interfaces.
	IsProcedureResultFieldContext()
}

type ProcedureResultFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureResultFieldContext() *ProcedureResultFieldContext {
	var p = new(ProcedureResultFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureResultField
	return p
}

func (*ProcedureResultFieldContext) IsProcedureResultFieldContext() {}

func NewProcedureResultFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureResultFieldContext {
	var p = new(ProcedureResultFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureResultField

	return p
}

func (s *ProcedureResultFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureResultFieldContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureResultFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureResultFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureResultFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureResultField(s)
	}
}

func (s *ProcedureResultFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureResultField(s)
	}
}

func (p *CypherParser) ProcedureResultField() (localctx IProcedureResultFieldContext) {
	localctx = NewProcedureResultFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CypherParserRULE_procedureResultField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1389)
		p.SymbolicName()
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) Namespace() INamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *ProcedureNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (p *CypherParser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CypherParserRULE_procedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		p.Namespace()
	}
	{
		p.SetState(1392)
		p.SymbolicName()
	}

	return localctx
}

// INamespaceContext is an interface to support dynamic dispatch.
type INamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceContext differentiates from other interfaces.
	IsNamespaceContext()
}

type NamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceContext() *NamespaceContext {
	var p = new(NamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_namespace
	return p
}

func (*NamespaceContext) IsNamespaceContext() {}

func NewNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceContext {
	var p = new(NamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_namespace

	return p
}

func (s *NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceContext) AllSymbolicName() []ISymbolicNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem())
	var tst = make([]ISymbolicNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicNameContext)
		}
	}

	return tst
}

func (s *NamespaceContext) SymbolicName(i int) ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNamespace(s)
	}
}

func (s *NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNamespace(s)
	}
}

func (p *CypherParser) Namespace() (localctx INamespaceContext) {
	localctx = NewNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CypherParserRULE_namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1394)
				p.SymbolicName()
			}
			{
				p.SetState(1395)
				p.Match(CypherParserT__23)
			}

		}
		p.SetState(1401)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext())
	}

	return localctx
}

// IListComprehensionContext is an interface to support dynamic dispatch.
type IListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListComprehensionContext differentiates from other interfaces.
	IsListComprehensionContext()
}

type ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListComprehensionContext() *ListComprehensionContext {
	var p = new(ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_listComprehension
	return p
}

func (*ListComprehensionContext) IsListComprehensionContext() {}

func NewListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListComprehensionContext {
	var p = new(ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_listComprehension

	return p
}

func (s *ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListComprehensionContext) FilterExpression() IFilterExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterExpressionContext)
}

func (s *ListComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *ListComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *ListComprehensionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterListComprehension(s)
	}
}

func (s *ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitListComprehension(s)
	}
}

func (p *CypherParser) ListComprehension() (localctx IListComprehensionContext) {
	localctx = NewListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CypherParserRULE_listComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		p.Match(CypherParserT__8)
	}
	p.SetState(1404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1403)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1406)
		p.FilterExpression()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
		p.SetState(1408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1407)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1410)
			p.Match(CypherParserT__11)
		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1411)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1414)
			p.Expression()
		}

	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1417)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1420)
		p.Match(CypherParserT__9)
	}

	return localctx
}

// IPatternComprehensionContext is an interface to support dynamic dispatch.
type IPatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternComprehensionContext differentiates from other interfaces.
	IsPatternComprehensionContext()
}

type PatternComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternComprehensionContext() *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_patternComprehension
	return p
}

func (*PatternComprehensionContext) IsPatternComprehensionContext() {}

func NewPatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternComprehensionContext {
	var p = new(PatternComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_patternComprehension

	return p
}

func (s *PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternComprehensionContext) RelationshipsPattern() IRelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationshipsPatternContext)
}

func (s *PatternComprehensionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PatternComprehensionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PatternComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PatternComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PatternComprehensionContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PatternComprehensionContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPatternComprehension(s)
	}
}

func (s *PatternComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPatternComprehension(s)
	}
}

func (p *CypherParser) PatternComprehension() (localctx IPatternComprehensionContext) {
	localctx = NewPatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CypherParserRULE_patternComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Match(CypherParserT__8)
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1423)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserALL || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(CypherParserCOUNT-84))|(1<<(CypherParserFILTER-84))|(1<<(CypherParserEXTRACT-84))|(1<<(CypherParserANY-84))|(1<<(CypherParserNONE-84))|(1<<(CypherParserSINGLE-84))|(1<<(CypherParserHexLetter-84)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName {
		{
			p.SetState(1426)
			p.Variable()
		}
		p.SetState(1428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1427)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1430)
			p.Match(CypherParserT__2)
		}
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1431)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1436)
		p.RelationshipsPattern()
	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1437)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserWHERE {
		{
			p.SetState(1440)
			p.Match(CypherParserWHERE)
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1441)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1444)
			p.Expression()
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1445)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1450)
		p.Match(CypherParserT__11)
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1451)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1454)
		p.Expression()
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1455)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1458)
		p.Match(CypherParserT__9)
	}

	return localctx
}

// IPropertyLookupContext is an interface to support dynamic dispatch.
type IPropertyLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyLookupContext differentiates from other interfaces.
	IsPropertyLookupContext()
}

type PropertyLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyLookupContext() *PropertyLookupContext {
	var p = new(PropertyLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyLookup
	return p
}

func (*PropertyLookupContext) IsPropertyLookupContext() {}

func NewPropertyLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyLookupContext {
	var p = new(PropertyLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyLookup

	return p
}

func (s *PropertyLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyLookupContext) PropertyKeyName() IPropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *PropertyLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *PropertyLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyLookup(s)
	}
}

func (s *PropertyLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyLookup(s)
	}
}

func (p *CypherParser) PropertyLookup() (localctx IPropertyLookupContext) {
	localctx = NewPropertyLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CypherParserRULE_propertyLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		p.Match(CypherParserT__23)
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1461)
			p.Match(CypherParserSP)
		}

	}

	{
		p.SetState(1464)
		p.PropertyKeyName()
	}

	return localctx
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseExpression
	return p
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *CaseExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CaseExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *CaseExpressionContext) AllCaseAlternatives() []ICaseAlternativesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseAlternativesContext)(nil)).Elem())
	var tst = make([]ICaseAlternativesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseAlternativesContext)
		}
	}

	return tst
}

func (s *CaseExpressionContext) CaseAlternatives(i int) ICaseAlternativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseAlternativesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativesContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (p *CypherParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CypherParserRULE_caseExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1466)
			p.Match(CypherParserCASE)
		}
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1468)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1467)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1470)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1473)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 267, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(1475)
			p.Match(CypherParserCASE)
		}
		p.SetState(1477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1476)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1479)
			p.Expression()
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1481)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == CypherParserSP {
					{
						p.SetState(1480)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1483)
					p.CaseAlternatives()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1486)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext())
		}

	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1490)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1493)
			p.Match(CypherParserELSE)
		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1494)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1497)
			p.Expression()
		}

	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1500)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1503)
		p.Match(CypherParserEND)
	}

	return localctx
}

// ICaseAlternativesContext is an interface to support dynamic dispatch.
type ICaseAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseAlternativesContext differentiates from other interfaces.
	IsCaseAlternativesContext()
}

type CaseAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativesContext() *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_caseAlternatives
	return p
}

func (*CaseAlternativesContext) IsCaseAlternativesContext() {}

func NewCaseAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativesContext {
	var p = new(CaseAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_caseAlternatives

	return p
}

func (s *CaseAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativesContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *CaseAlternativesContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CaseAlternativesContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativesContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *CaseAlternativesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *CaseAlternativesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *CaseAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterCaseAlternatives(s)
	}
}

func (s *CaseAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitCaseAlternatives(s)
	}
}

func (p *CypherParser) CaseAlternatives() (localctx ICaseAlternativesContext) {
	localctx = NewCaseAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CypherParserRULE_caseAlternatives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1505)
		p.Match(CypherParserWHEN)
	}
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1506)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1509)
		p.Expression()
	}
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1510)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1513)
		p.Match(CypherParserTHEN)
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1514)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1517)
		p.Expression()
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (p *CypherParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CypherParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.SymbolicName()
	}

	return localctx
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_numberLiteral
	return p
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) DoubleLiteral() IDoubleLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoubleLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoubleLiteralContext)
}

func (s *NumberLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *CypherParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CypherParserRULE_numberLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1521)
			p.DoubleLiteral()
		}

	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1522)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_mapLiteral
	return p
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *MapLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *MapLiteralContext) AllPropertyKeyName() []IPropertyKeyNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem())
	var tst = make([]IPropertyKeyNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyKeyNameContext)
		}
	}

	return tst
}

func (s *MapLiteralContext) PropertyKeyName(i int) IPropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyKeyNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyNameContext)
}

func (s *MapLiteralContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MapLiteralContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

func (p *CypherParser) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CypherParserRULE_mapLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.Match(CypherParserT__24)
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == CypherParserSP {
		{
			p.SetState(1526)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(CypherParserUNION-47))|(1<<(CypherParserALL-47))|(1<<(CypherParserOPTIONAL-47))|(1<<(CypherParserMATCH-47))|(1<<(CypherParserUNWIND-47))|(1<<(CypherParserAS-47))|(1<<(CypherParserMERGE-47))|(1<<(CypherParserON-47))|(1<<(CypherParserCREATE-47))|(1<<(CypherParserSET-47))|(1<<(CypherParserDETACH-47))|(1<<(CypherParserDELETE-47))|(1<<(CypherParserREMOVE-47))|(1<<(CypherParserWITH-47))|(1<<(CypherParserDISTINCT-47))|(1<<(CypherParserRETURN-47))|(1<<(CypherParserORDER-47))|(1<<(CypherParserBY-47))|(1<<(CypherParserL_SKIP-47))|(1<<(CypherParserLIMIT-47))|(1<<(CypherParserASCENDING-47))|(1<<(CypherParserASC-47))|(1<<(CypherParserDESCENDING-47))|(1<<(CypherParserDESC-47))|(1<<(CypherParserWHERE-47))|(1<<(CypherParserOR-47))|(1<<(CypherParserXOR-47))|(1<<(CypherParserAND-47))|(1<<(CypherParserNOT-47))|(1<<(CypherParserIN-47)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(CypherParserSTARTS-79))|(1<<(CypherParserENDS-79))|(1<<(CypherParserCONTAINS-79))|(1<<(CypherParserIS-79))|(1<<(CypherParserNULL-79))|(1<<(CypherParserCOUNT-79))|(1<<(CypherParserFILTER-79))|(1<<(CypherParserEXTRACT-79))|(1<<(CypherParserANY-79))|(1<<(CypherParserNONE-79))|(1<<(CypherParserSINGLE-79))|(1<<(CypherParserTRUE-79))|(1<<(CypherParserFALSE-79))|(1<<(CypherParserEXISTS-79))|(1<<(CypherParserCASE-79))|(1<<(CypherParserELSE-79))|(1<<(CypherParserEND-79))|(1<<(CypherParserWHEN-79))|(1<<(CypherParserTHEN-79))|(1<<(CypherParserHexLetter-79)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(CypherParserCONSTRAINT-112))|(1<<(CypherParserDO-112))|(1<<(CypherParserFOR-112))|(1<<(CypherParserREQUIRE-112))|(1<<(CypherParserUNIQUE-112))|(1<<(CypherParserMANDATORY-112))|(1<<(CypherParserSCALAR-112))|(1<<(CypherParserOF-112))|(1<<(CypherParserADD-112))|(1<<(CypherParserDROP-112))|(1<<(CypherParserUnescapedSymbolicName-112))|(1<<(CypherParserEscapedSymbolicName-112)))) != 0) {
		{
			p.SetState(1529)
			p.PropertyKeyName()
		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1530)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1533)
			p.Match(CypherParserT__10)
		}
		p.SetState(1535)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1534)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1537)
			p.Expression()
		}
		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == CypherParserSP {
			{
				p.SetState(1538)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == CypherParserT__1 {
			{
				p.SetState(1541)
				p.Match(CypherParserT__1)
			}
			p.SetState(1543)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1542)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1545)
				p.PropertyKeyName()
			}
			p.SetState(1547)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1546)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1549)
				p.Match(CypherParserT__10)
			}
			p.SetState(1551)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1550)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1553)
				p.Expression()
			}
			p.SetState(1555)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1554)
					p.Match(CypherParserSP)
				}

			}

			p.SetState(1561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1564)
		p.Match(CypherParserT__25)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *ParameterContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *CypherParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CypherParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.Match(CypherParserT__26)
	}
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserALL, CypherParserCOUNT, CypherParserFILTER, CypherParserEXTRACT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(1567)
			p.SymbolicName()
		}

	case CypherParserDecimalInteger:
		{
			p.SetState(1568)
			p.Match(CypherParserDecimalInteger)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyExpressionContext is an interface to support dynamic dispatch.
type IPropertyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyExpressionContext differentiates from other interfaces.
	IsPropertyExpressionContext()
}

type PropertyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyExpressionContext() *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyExpression
	return p
}

func (*PropertyExpressionContext) IsPropertyExpressionContext() {}

func NewPropertyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyExpressionContext {
	var p = new(PropertyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyExpression

	return p
}

func (s *PropertyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyExpressionContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PropertyExpressionContext) AllPropertyLookup() []IPropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem())
	var tst = make([]IPropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyLookupContext)
		}
	}

	return tst
}

func (s *PropertyExpressionContext) PropertyLookup(i int) IPropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyLookupContext)
}

func (s *PropertyExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *PropertyExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *PropertyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyExpression(s)
	}
}

func (s *PropertyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyExpression(s)
	}
}

func (p *CypherParser) PropertyExpression() (localctx IPropertyExpressionContext) {
	localctx = NewPropertyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CypherParserRULE_propertyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.Atom()
	}
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(1573)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == CypherParserSP {
				{
					p.SetState(1572)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1575)
				p.PropertyLookup()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1578)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext())
	}

	return localctx
}

// IPropertyKeyNameContext is an interface to support dynamic dispatch.
type IPropertyKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyKeyNameContext differentiates from other interfaces.
	IsPropertyKeyNameContext()
}

type PropertyKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyNameContext() *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_propertyKeyName
	return p
}

func (*PropertyKeyNameContext) IsPropertyKeyNameContext() {}

func NewPropertyKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyNameContext {
	var p = new(PropertyKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_propertyKeyName

	return p
}

func (s *PropertyKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *PropertyKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterPropertyKeyName(s)
	}
}

func (s *PropertyKeyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitPropertyKeyName(s)
	}
}

func (p *CypherParser) PropertyKeyName() (localctx IPropertyKeyNameContext) {
	localctx = NewPropertyKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CypherParserRULE_propertyKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1580)
		p.SchemaName()
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) HexInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserHexInteger, 0)
}

func (s *IntegerLiteralContext) OctalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserOctalInteger, 0)
}

func (s *IntegerLiteralContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *CypherParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CypherParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1582)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(CypherParserHexInteger-100))|(1<<(CypherParserDecimalInteger-100))|(1<<(CypherParserOctalInteger-100)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDoubleLiteralContext is an interface to support dynamic dispatch.
type IDoubleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoubleLiteralContext differentiates from other interfaces.
	IsDoubleLiteralContext()
}

type DoubleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleLiteralContext() *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_doubleLiteral
	return p
}

func (*DoubleLiteralContext) IsDoubleLiteralContext() {}

func NewDoubleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_doubleLiteral

	return p
}

func (s *DoubleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleLiteralContext) ExponentDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserExponentDecimalReal, 0)
}

func (s *DoubleLiteralContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserRegularDecimalReal, 0)
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

func (p *CypherParser) DoubleLiteral() (localctx IDoubleLiteralContext) {
	localctx = NewDoubleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CypherParserRULE_doubleLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1584)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserExponentDecimalReal || _la == CypherParserRegularDecimalReal) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_schemaName
	return p
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) SymbolicName() ISymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicNameContext)
}

func (s *SchemaNameContext) ReservedWord() IReservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (p *CypherParser) SchemaName() (localctx ISchemaNameContext) {
	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CypherParserRULE_schemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1586)
			p.SymbolicName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1587)
			p.ReservedWord()
		}

	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *ReservedWordContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *ReservedWordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *ReservedWordContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *ReservedWordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *ReservedWordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *ReservedWordContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *ReservedWordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *ReservedWordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *ReservedWordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *ReservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *ReservedWordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *ReservedWordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *ReservedWordContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *ReservedWordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *ReservedWordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *ReservedWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *ReservedWordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *ReservedWordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *ReservedWordContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *ReservedWordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *ReservedWordContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *ReservedWordContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *ReservedWordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *ReservedWordContext) AND() antlr.TerminalNode {
	return s.GetToken(CypherParserAND, 0)
}

func (s *ReservedWordContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *ReservedWordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *ReservedWordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *ReservedWordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *ReservedWordContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *ReservedWordContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *ReservedWordContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *ReservedWordContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *ReservedWordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *ReservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, 0)
}

func (s *ReservedWordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *ReservedWordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *ReservedWordContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *ReservedWordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *ReservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(CypherParserDO, 0)
}

func (s *ReservedWordContext) FOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFOR, 0)
}

func (s *ReservedWordContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRE, 0)
}

func (s *ReservedWordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *ReservedWordContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *ReservedWordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *ReservedWordContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *ReservedWordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *ReservedWordContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *ReservedWordContext) MANDATORY() antlr.TerminalNode {
	return s.GetToken(CypherParserMANDATORY, 0)
}

func (s *ReservedWordContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(CypherParserSCALAR, 0)
}

func (s *ReservedWordContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *ReservedWordContext) ADD() antlr.TerminalNode {
	return s.GetToken(CypherParserADD, 0)
}

func (s *ReservedWordContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (p *CypherParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CypherParserRULE_reservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1590)
	_la = p.GetTokenStream().LA(1)

	if !((((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(CypherParserUNION-47))|(1<<(CypherParserALL-47))|(1<<(CypherParserOPTIONAL-47))|(1<<(CypherParserMATCH-47))|(1<<(CypherParserUNWIND-47))|(1<<(CypherParserAS-47))|(1<<(CypherParserMERGE-47))|(1<<(CypherParserON-47))|(1<<(CypherParserCREATE-47))|(1<<(CypherParserSET-47))|(1<<(CypherParserDETACH-47))|(1<<(CypherParserDELETE-47))|(1<<(CypherParserREMOVE-47))|(1<<(CypherParserWITH-47))|(1<<(CypherParserDISTINCT-47))|(1<<(CypherParserRETURN-47))|(1<<(CypherParserORDER-47))|(1<<(CypherParserBY-47))|(1<<(CypherParserL_SKIP-47))|(1<<(CypherParserLIMIT-47))|(1<<(CypherParserASCENDING-47))|(1<<(CypherParserASC-47))|(1<<(CypherParserDESCENDING-47))|(1<<(CypherParserDESC-47))|(1<<(CypherParserWHERE-47))|(1<<(CypherParserOR-47))|(1<<(CypherParserXOR-47))|(1<<(CypherParserAND-47))|(1<<(CypherParserNOT-47))|(1<<(CypherParserIN-47)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(CypherParserSTARTS-79))|(1<<(CypherParserENDS-79))|(1<<(CypherParserCONTAINS-79))|(1<<(CypherParserIS-79))|(1<<(CypherParserNULL-79))|(1<<(CypherParserTRUE-79))|(1<<(CypherParserFALSE-79))|(1<<(CypherParserEXISTS-79))|(1<<(CypherParserCASE-79))|(1<<(CypherParserELSE-79))|(1<<(CypherParserEND-79))|(1<<(CypherParserWHEN-79))|(1<<(CypherParserTHEN-79)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(CypherParserCONSTRAINT-112))|(1<<(CypherParserDO-112))|(1<<(CypherParserFOR-112))|(1<<(CypherParserREQUIRE-112))|(1<<(CypherParserUNIQUE-112))|(1<<(CypherParserMANDATORY-112))|(1<<(CypherParserSCALAR-112))|(1<<(CypherParserOF-112))|(1<<(CypherParserADD-112))|(1<<(CypherParserDROP-112)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISymbolicNameContext is an interface to support dynamic dispatch.
type ISymbolicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicNameContext differentiates from other interfaces.
	IsSymbolicNameContext()
}

type SymbolicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicNameContext() *SymbolicNameContext {
	var p = new(SymbolicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_symbolicName
	return p
}

func (*SymbolicNameContext) IsSymbolicNameContext() {}

func NewSymbolicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicNameContext {
	var p = new(SymbolicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_symbolicName

	return p
}

func (s *SymbolicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserUnescapedSymbolicName, 0)
}

func (s *SymbolicNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserEscapedSymbolicName, 0)
}

func (s *SymbolicNameContext) HexLetter() antlr.TerminalNode {
	return s.GetToken(CypherParserHexLetter, 0)
}

func (s *SymbolicNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *SymbolicNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *SymbolicNameContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *SymbolicNameContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *SymbolicNameContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *SymbolicNameContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *SymbolicNameContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *SymbolicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterSymbolicName(s)
	}
}

func (s *SymbolicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitSymbolicName(s)
	}
}

func (p *CypherParser) SymbolicName() (localctx ISymbolicNameContext) {
	localctx = NewSymbolicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CypherParserRULE_symbolicName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1592)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserALL || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(CypherParserCOUNT-84))|(1<<(CypherParserFILTER-84))|(1<<(CypherParserEXTRACT-84))|(1<<(CypherParserANY-84))|(1<<(CypherParserNONE-84))|(1<<(CypherParserSINGLE-84))|(1<<(CypherParserHexLetter-84)))) != 0) || _la == CypherParserUnescapedSymbolicName || _la == CypherParserEscapedSymbolicName) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ILeftArrowHeadContext is an interface to support dynamic dispatch.
type ILeftArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLeftArrowHeadContext differentiates from other interfaces.
	IsLeftArrowHeadContext()
}

type LeftArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftArrowHeadContext() *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_leftArrowHead
	return p
}

func (*LeftArrowHeadContext) IsLeftArrowHeadContext() {}

func NewLeftArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftArrowHeadContext {
	var p = new(LeftArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_leftArrowHead

	return p
}

func (s *LeftArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *LeftArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterLeftArrowHead(s)
	}
}

func (s *LeftArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitLeftArrowHead(s)
	}
}

func (p *CypherParser) LeftArrowHead() (localctx ILeftArrowHeadContext) {
	localctx = NewLeftArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CypherParserRULE_leftArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1594)
	_la = p.GetTokenStream().LA(1)

	if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<CypherParserT__19)|(1<<CypherParserT__27)|(1<<CypherParserT__28)|(1<<CypherParserT__29)|(1<<CypherParserT__30))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IRightArrowHeadContext is an interface to support dynamic dispatch.
type IRightArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRightArrowHeadContext differentiates from other interfaces.
	IsRightArrowHeadContext()
}

type RightArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRightArrowHeadContext() *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_rightArrowHead
	return p
}

func (*RightArrowHeadContext) IsRightArrowHeadContext() {}

func NewRightArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RightArrowHeadContext {
	var p = new(RightArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_rightArrowHead

	return p
}

func (s *RightArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *RightArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RightArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterRightArrowHead(s)
	}
}

func (s *RightArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitRightArrowHead(s)
	}
}

func (p *CypherParser) RightArrowHead() (localctx IRightArrowHeadContext) {
	localctx = NewRightArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CypherParserRULE_rightArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1596)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-21)&-(0x1f+1)) == 0 && ((1<<uint((_la-21)))&((1<<(CypherParserT__20-21))|(1<<(CypherParserT__31-21))|(1<<(CypherParserT__32-21))|(1<<(CypherParserT__33-21))|(1<<(CypherParserT__34-21)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDashContext is an interface to support dynamic dispatch.
type IDashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDashContext differentiates from other interfaces.
	IsDashContext()
}

type DashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDashContext() *DashContext {
	var p = new(DashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_dash
	return p
}

func (*DashContext) IsDashContext() {}

func NewDashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DashContext {
	var p = new(DashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_dash

	return p
}

func (s *DashContext) GetParser() antlr.Parser { return s.parser }
func (s *DashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterDash(s)
	}
}

func (s *DashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitDash(s)
	}
}

func (p *CypherParser) Dash() (localctx IDashContext) {
	localctx = NewDashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CypherParserRULE_dash)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1598)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserT__4 || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(CypherParserT__35-36))|(1<<(CypherParserT__36-36))|(1<<(CypherParserT__37-36))|(1<<(CypherParserT__38-36))|(1<<(CypherParserT__39-36))|(1<<(CypherParserT__40-36))|(1<<(CypherParserT__41-36))|(1<<(CypherParserT__42-36))|(1<<(CypherParserT__43-36))|(1<<(CypherParserT__44-36))|(1<<(CypherParserT__45-36)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}
